0000              1    ; Implementation of the finite state machine to control the stages of the reflow oven
0000              2   
                  4   $LIST
0000              6   
0000              7   ;  N76E003 pinout:
0000              8   ;                               -------
0000              9   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             10   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             11   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             12   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             13   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             14   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             15   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             16   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             17   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             18   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             19   ;                               -------
0000             20   ;
0000             21   
0000             22   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD          EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER0_RATE   EQU 2048     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             25   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             27   TIMER2_RATE   EQU 100      ; 100Hz or 10ms
0000             28   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 2 input divide to 16 in T2MOD
0000             29   
0000             30   ; Relevant vectors
0000             31   ; Reset vector
0000             32   org 0x0000
0000 0205E0      33       ljmp initialize
0003             34   
0003             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 0203FD      37            ljmp Timer0_ISR
000E             38   
000E             39   ; Timer/Counter 2 overflow interrupt vector
002B             40   org 0x002B
002B 020427      41            ljmp Timer2_ISR
002E             42            
002E             43            
002E             44   ;;;;;;;;;;;;
002E             45   ;   PINS   ;
002E             46   ;;;;;;;;;;;;
002E             47      
002E             48   LCD_RS     equ P1.3
002E             49   ;LCD_RW    equ PX.X  ; Not used in this code, connect the pin to GND
002E             50   LCD_E      equ P1.4
002E             51   LCD_D4     equ P0.0
002E             52   LCD_D5     equ P0.1
002E             53   LCD_D6     equ P0.2
002E             54   LCD_D7     equ P0.3   
002E             55   PWM_OUT    equ P1.0 ; Toggles power to the oven (Logic 1=oven on)
002E             56   SOUND_OUT  equ P0.4 ; Speaker connection 
002E             57   
002E             58   ; Decleration of one byte current state variable and parameters
0030             59   DSEG at 0x30
0030             60   Count1ms:      ds 2 ; Used to determine when a second has passed
0032             61   soak_temp:     ds 1 ; User set variable for the desired soak temperature
0033             62   soak_time:     ds 2 ; User set variable for the length of the soak time
0035             63   current_soak_time: ds 2
0037             64   reflow_temp:   ds 2 ; User set variable for the reflow temperature
0039             65   reflow_time:   ds 1 ; User set variable for timein the reflow state
003A             66   current_temp:  ds 1 ; Current temperature in the oven
003B             67   current_time:  ds 1 ; Current time placeholder used for LCD purposes
003C             68   state_time:    ds 1 ; Current amount of time we have been in a given state
003D             69   current_state: ds 1 ; Current state of the finite state machine
003E             70   pwm_counter:   ds 1 ; Free running counter 0, 1, 2, ..., 100, 0 used for PWM purposes
003F             71   pwm:           ds 1 ; pwm percentage variable - adjust as needed in each state
0040             72   
0040             73   
0040             74   ;for math_32.inc library
0040             75   x:   ds 4
0044             76   y:   ds 4
0048             77   bcd: ds 5
004D             78   
004D             79   ; decleration of one bit variables (flags)
0000             80   BSEG
0000             81   ; These one bit variables store the value of the pushbuttons after calling 'LCD_PB' 
0000             82   PB0:                     dbit 1 ; incremement (INC)
0001             83   PB1:                     dbit 1 ; decremement (DEC)
0002             84   PB2:                     dbit 1 ; next parameter (NXT)
0003             85   PB3:                     dbit 1 ; currently unused (PB3)
0004             86   PB4:                     dbit 1 ; start / emergency stop (EMR)
0005             87   display_time:       dbit 1 ; if this flag is set, we want to start displaying the state time
0006             88   new_state:          dbit 1 ; if this flag is set, we want to make a speaker beep
0007             89   cooling_done:       dbit 1 ; flag set if cooling state is finished
0008             90   mf:                 dbit 1 ; used for math functions  
0009             91   one_second_flag:    dbit 1 ; set every 1 second, time displays, then cleared
000A             92   
002E             93   CSEG
002E             94   
002E             95   ; Strings
002E             96   ;                '1234567890123456'
002E 546F3D20    97   initial_msg1: DB 'To=    C  Tj=20C',0
     20202043
     2020546A
     3D323043
     00
003F 73312020    98   initial_mgs2: DB 's1  ,    r   ,  ',0
     2C202020
     20722020
     202C2020
     00
0050             99   ;         s=soak temp, soak time   r=reflow temp,reflow time
0050            100   
0050            101   ;state name messages
0050            102   ;                '1234567890123456'
0050 743D2020   103   preheat_mgs: DB    't=       Preheat',0
     20202020
     20507265
     68656174
     00
0061 743D2020   104   soak_mgs:    DB    't=       Soaking',0
     20202020
     20536F61
     6B696E67
     00
0072 743D2020   105   ramp_mgs:    DB    't=          Ramp',0
     20202020
     20202020
     52616D70
     00
0083 743D2020   106   reflow_mgs:  DB    't=        Reflow',0
     20202020
     20205265
     666C6F77
     00
0094 743D2020   107   cooling_mgs: DB    't=       Cooling',0
     20202020
     20436F6F
     6C696E67
     00
00A5            108   
00A5            109   
00A5            110   ; A library of LCD related functions and utility macros
                112   $LIST
0159            114   
0159            115   ; A library of math related functions and utility macros
                579   $LIST
                117   $LIST
03E7            119   
03E7            120   ; Initialization of timers
03E7            121   ;---------------------------------;
03E7            122   ; Routine to initialize the ISR   ;
03E7            123   ; for timer 0                     ;
03E7            124   ;---------------------------------;
03E7            125   Timer0_Init:
03E7 438E08     126            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03EA E589       127            mov a, TMOD
03EC 54F0       128            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03EE 4401       129            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03F0 F589       130            mov TMOD, a
03F2 758CE0     131            mov TH0, #high(TIMER0_RELOAD)
03F5 758A57     132            mov TL0, #low(TIMER0_RELOAD)
03F8            133            ; Enable the timer and interrupts
03F8 D2A9       134       setb ET0  ; Enable timer 0 interrupt
03FA D28C       135       setb TR0  ; Start timer 0
03FC 22         136            ret
03FD            137   
03FD            138   ;---------------------------------;
03FD            139   ; ISR for timer 0.  Set to execute;
03FD            140   ; every 1/2048Hz to generate a    ;
03FD            141   ; 2048 Hz wave at pin SOUND_OUT   ;
03FD            142   ;---------------------------------;
03FD            143   Timer0_ISR:
03FD            144            ;clr TF0  ; According to the data sheet this is done for us already.
03FD            145            ; Timer 0 doesn't have 16-bit auto-reload, so
03FD C28C       146            clr TR0
03FF 758CE0     147            mov TH0, #high(TIMER0_RELOAD)
0402 758A57     148            mov TL0, #low(TIMER0_RELOAD)
0405 D28C       149            setb TR0
0407 B284       150            cpl SOUND_OUT ; Toggles the speaker pin at 1000 Hz to play noise
0409 32         151            reti
040A            152   
040A            153   ;---------------------------------;
040A            154   ; Routine to initialize the ISR   ;
040A            155   ; for timer 2                     ;
040A            156   ;---------------------------------;
040A            157   Timer2_Init:
040A            158            ; Initialize timer 2 for periodic interrupts
040A 75C800     159            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
040D 75CDD7     160            mov TH2, #high(TIMER2_RELOAD)
0410 75CC79     161            mov TL2, #low(TIMER2_RELOAD)
0413            162            ; Set the reload value
0413 75C9A0     163            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0416 75CBD7     164            mov RCMP2H, #high(TIMER2_RELOAD)
0419 75CA79     165            mov RCMP2L, #low(TIMER2_RELOAD)
041C            166            ; Init the free running 10 ms counter to zero
041C 753E00     167            mov pwm_counter, #0
041F            168            ; Enable the timer and interrupts
041F 439B80     169            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0422 D2CA       170       setb TR2  ; Enable timer 2
0424 D2AF       171            setb EA ; Enable global interrupts
0426            172   
0426 22         173            ret 
0427            174   
0427            175   ;---------------------------------;
0427            176   ; ISR for timer 2                 ;
0427            177   ;---------------------------------;
0427            178   Timer2_ISR:
0427 C2CF       179            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0429 C0D0       180            push psw
042B C0E0       181            push acc
042D            182            
042D 053E       183            inc pwm_counter
042F C3         184            clr c
0430 E53F       185            mov a, pwm
0432 953E       186            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0434 B3         187            cpl c
0435 9290       188            mov PWM_OUT, c
0437            189            
0437 E53E       190            mov a, pwm_counter
0439 B4640E     191            cjne a, #100, Timer2_ISR_done ; check if 1000 ms have passed
043C 753E00     192            mov pwm_counter, #0
043F D209       193            setb one_second_flag ; set this flag every 1 second, display the time, then it gets cleared
0441 C28C       194            clr TR0 ; default speaker sound to OFF
0443            195   
0443 300604     196            jnb new_state, Timer2_ISR_done ; if we are not entering a new state, jump to the send serial port code
0446 B28C       197            cpl TR0 ; Enable timer/counter 0. This line enables the beep sound from the speaker when we enter a new state
0448 C206       198            clr new_state 
044A            199   
044A            200   Timer2_ISR_done:
044A D0E0       201            pop acc
044C D0D0       202            pop psw
044E 32         203            reti
044F            204   
044F            205   ; Function declearations begins here:
044F            206   ; We can display a number any way we want.  In this case with four decimal places.
044F            207   Display_formated_BCD:
044F C0E0       208            push acc
0451 7405       208            mov a, #5
0453 14         208            dec a
0454 12013C     208            lcall ?Set_Cursor_2 ; Select column and row
0457 D0E0       208            pop acc
0459 C000       209            push ar0
045B A84C       209            mov r0, bcd+4
045D 120143     209            lcall ?Display_BCD
0460 D000       209            pop ar0
0462 C000       210            push ar0
0464 A84B       210            mov r0, bcd+3
0466 120143     210            lcall ?Display_BCD
0469 D000       210            pop ar0
046B C000       211            push ar0
046D A84A       211            mov r0, bcd+2
046F 120143     211            lcall ?Display_BCD
0472 D000       211            pop ar0
0474 C0E0       212            push acc
0476 742E       212            mov a, #'.'
0478 1200F4     212            lcall ?WriteData
047B D0E0       212            pop acc
047D C000       213            push ar0
047F A849       213            mov r0, bcd+1
0481 120143     213            lcall ?Display_BCD
0484 D000       213            pop ar0
0486 C000       214            push ar0
0488 A848       214            mov r0, bcd+0
048A 120143     214            lcall ?Display_BCD
048D D000       214            pop ar0
048F C0E0       215            push acc
0491 7406       215            mov a, #6
0493 14         215            dec a
0494 12013C     215            lcall ?Set_Cursor_2 ; Select column and row
0497 D0E0       215            pop acc
0499            216            
0499 22         217            ret
049A            218   
049A            219   Read_ADC:
049A C2EF       220            clr ADCF
049C D2EE       221            setb ADCS ;  ADC start trigger signal
049E 30EFFD     222       jnb ADCF, $ ; Wait for conversion complete
04A1            223       
04A1            224       ; Read the ADC result and store in [R1, R0]
04A1 E5C2       225       mov a, ADCRL
04A3 540F       226       anl a, #0x0f
04A5 F8         227       mov R0, a
04A6 E5C3       228       mov a, ADCRH   
04A8 C4         229       swap a
04A9 C0E0       230       push acc
04AB 540F       231       anl a, #0x0f
04AD F9         232       mov R1, a
04AE D0E0       233       pop acc
04B0 54F0       234       anl a, #0xf0
04B2 48         235       orl a, R0
04B3 F8         236       mov R0, A
04B4 22         237            ret
04B5            238            
04B5            239   
04B5            240   ; this function reads the overall temperature
04B5            241   ; (cold + hot) junction and turns the value in bcd
04B5            242   Read_Temp:
04B5            243            ; Read the signal connected to AIN7
04B5 53E8F0     244            anl ADCCON0, #0xF0
04B8 43E807     245            orl ADCCON0, #0x07 ; Select channel 7
04BB            246   Average_ADC:
04BB 754000     247            mov x+0, #low (0 % 0x10000) 
04BE 754100     247            mov x+1, #high(0 % 0x10000) 
04C1 754200     247            mov x+2, #low (0 / 0x10000) 
04C4 754300     247            mov x+3, #high(0 / 0x10000) 
04C7 7D64       248            mov r5, #100
04C9            249   Sum_loop0:
04C9 12049A     250            lcall Read_ADC
04CC            251       
04CC            252       ; Convert to voltage
04CC 8844       253            mov y+0, R0
04CE 8945       254            mov y+1, R1
04D0 754600     255            mov y+2, #0
04D3 754700     256            mov y+3, #0
04D6            257   
04D6 12023C     258            lcall add32
04D9 DDEE       259            djnz r5, Sum_loop0
04DB            260   
04DB 754464     261            mov y+0, #low (100 % 0x10000) 
04DE 754500     261            mov y+1, #high(100 % 0x10000) 
04E1 754600     261            mov y+2, #low (100 / 0x10000) 
04E4 754700     261            mov y+3, #high(100 / 0x10000) 
04E7 12037E     262            lcall div32
04EA            263   
04EA 7544C8     264            mov y+0, #low (51400 % 0x10000) 
04ED 7545C8     264            mov y+1, #high(51400 % 0x10000) 
04F0 754600     264            mov y+2, #low (51400 / 0x10000) 
04F3 754700     264            mov y+3, #high(51400 / 0x10000)  ; VCC voltage measured
04F6 1202F1     265            lcall mul32
04F9 7544FF     266            mov y+0, #low (4095 % 0x10000) 
04FC 75450F     266            mov y+1, #high(4095 % 0x10000) 
04FF 754600     266            mov y+2, #low (4095 / 0x10000) 
0502 754700     266            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0505 12037E     267            lcall div32
0508            268   
0508            269            ;Load_y(1000)
0508            270            ;lcall mul32
0508            271   
0508 754464     272            mov y+0, #low (100 % 0x10000) 
050B 754500     272            mov y+1, #high(100 % 0x10000) 
050E 754600     272            mov y+2, #low (100 / 0x10000) 
0511 754700     272            mov y+3, #high(100 / 0x10000) 
0514 1202F1     273            lcall mul32
0517            274   
0517 75445B     275            mov y+0, #low (91 % 0x10000) 
051A 754500     275            mov y+1, #high(91 % 0x10000) 
051D 754600     275            mov y+2, #low (91 / 0x10000) 
0520 754700     275            mov y+3, #high(91 / 0x10000) 
0523 12037E     276            lcall div32
0526            277   
0526 754429     278            mov y+0, #low (41 % 0x10000) 
0529 754500     278            mov y+1, #high(41 % 0x10000) 
052C 754600     278            mov y+2, #low (41 / 0x10000) 
052F 754700     278            mov y+3, #high(41 / 0x10000) 
0532 12037E     279            lcall div32
0535            280   
0535 754414     281            mov y+0, #low (20 % 0x10000) 
0538 754500     281            mov y+1, #high(20 % 0x10000) 
053B 754600     281            mov y+2, #low (20 / 0x10000) 
053E 754700     281            mov y+3, #high(20 / 0x10000) 
0541 12023C     282            lcall add32
0544            283   
0544            284            ;Load_y(10000) ;This may be too much, try 100
0544            285            ;lcall mul32
0544            286   
0544            287            ; Convert to BCD and display
0544 120177     288            lcall hex2bcd
0547 C0E0       289            push acc
0549 7404       289            mov a, #4
054B 14         289            dec a
054C 12013E     289            lcall ?Set_Cursor_1 ; Select column and row
054F D0E0       289            pop acc
0551 C000       290            push ar0
0553 A849       290            mov r0, bcd+1
0555 120143     290            lcall ?Display_BCD
0558 D000       290            pop ar0
055A C000       291            push ar0
055C A848       291            mov r0, bcd+0
055E 120143     291            lcall ?Display_BCD
0561 D000       291            pop ar0
0563            292   
0563 7482       293            mov a, #0x82
0565 1200F9     293            lcall ?WriteCommand
0568 C0E0       294            push acc
056A 743D       294            mov a, #'='
056C 1200F4     294            lcall ?WriteData
056F D0E0       294            pop acc
0571            295            
0571            296            ; Wait 50 ms between conversions
0571 7A64       297            mov R2, #100
0573 1205CD     298            lcall waitms
0576            299   
0576 22         300            ret
0577            301   
0577            302   ;------------------------------------;
0577            303   ; Check for pushbutton press         ;
0577            304   ;------------------------------------;
0577            305   LCD_PB:
0577            306            ; Set variables to 1: 'no push button pressed'
0577 D200       307            setb PB0
0579 D201       308            setb PB1
057B D202       309            setb PB2
057D D203       310            setb PB3
057F D204       311            setb PB4
0581            312            ; The input pin used to check set to '1'
0581 D295       313            setb P1.5
0583            314            
0583            315            ; Check if any push button is pressed
0583 C280       316            clr P0.0
0585 C281       317            clr P0.1
0587 C282       318            clr P0.2
0589 C283       319            clr P0.3
058B C293       320            clr P1.3
058D 20953C     321            jb P1.5, LCD_PB_Done
0590            322   
0590            323            ; Debounce
0590 7A32       324            mov R2, #50
0592 1205CD     325            lcall waitms
0595 209534     326            jb P1.5, LCD_PB_Done
0598            327   
0598            328            ; Set the LCD data pins to logic 1
0598 D280       329            setb P0.0
059A D281       330            setb P0.1
059C D282       331            setb P0.2
059E D283       332            setb P0.3
05A0 D293       333            setb P1.3
05A2            334            
05A2            335            ; Check the push buttons one by one
05A2 C293       336            clr P1.3
05A4 A295       337            mov c, P1.5
05A6 9200       338            mov PB0, c
05A8 D293       339            setb P1.3
05AA            340   
05AA C280       341            clr P0.0
05AC A295       342            mov c, P1.5
05AE 9201       343            mov PB1, c
05B0 D280       344            setb P0.0
05B2            345            
05B2 C281       346            clr P0.1
05B4 A295       347            mov c, P1.5
05B6 9202       348            mov PB2, c
05B8 D281       349            setb P0.1
05BA            350            
05BA C282       351            clr P0.2
05BC A295       352            mov c, P1.5
05BE 9203       353            mov PB3, c
05C0 D282       354            setb P0.2
05C2            355            
05C2 C283       356            clr P0.3
05C4 A295       357            mov c, P1.5
05C6 9204       358            mov PB4, c
05C8 D283       359            setb P0.3
05CA            360   
05CA            361            ; If a button was pressed, set the flag
05CA 7B01       362            mov R3, #1
05CC            363   
05CC            364   LCD_PB_Done:             
05CC 22         365            ret
05CD            366   
05CD            367   ;---------------------------------;
05CD            368   ; Wait 'R2' milliseconds          ;
05CD            369   ;---------------------------------;
05CD            370   waitms:
05CD C000       371       push AR0
05CF C001       372       push AR1
05D1 7928       373   L6: mov R1, #40
05D3 7868       374   L5: mov R0, #104
05D5 D8FE       375   L4: djnz R0, L4 ; 4 cycles->4*60.24ns*104=25.0us
05D7 D9FA       376       djnz R1, L5 ; 25us*40=1.0ms
05D9 DAF6       377       djnz R2, L6 ; number of millisecons to wait passed in R2
05DB D001       378       pop AR1
05DD D000       379       pop AR0
05DF 22         380       ret
05E0            381   
05E0            382   
05E0            383   ; Main program code begins here!
05E0            384   initialize:
05E0            385   
05E0            386            ;;;;;;;;;;;;;;;;;;;
05E0            387            ;; CONFIGURATION ;;
05E0            388            ;;;;;;;;;;;;;;;;;;;
05E0            389   
05E0            390            ; Set the stack pointer!
05E0 75817F     391            mov sp, #0x7f
05E3            392   
05E3            393            ; Configure all the pins for biderectional I/O
05E3 75AC00     394            mov     P3M1, #0x00
05E6 75AD00     395            mov     P3M2, #0x00
05E9 75B300     396            mov     P1M1, #0x00
05EC 75B400     397            mov     P1M2, #0x00
05EF 75B100     398            mov     P0M1, #0x00
05F2 75B200     399            mov     P0M2, #0x00
05F5            400   
05F5            401            ; The following code initializes the serial port
05F5 438E10     402            orl     CKCON, #0x10 ; CLK is the input for timer 1
05F8 438780     403            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
05FB 759852     404            mov     SCON, #0x52
05FE 53C4DF     405            anl     T3CON, #0b11011111
0601 53890F     406            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0604 438920     407            orl     TMOD, #0x20 ; Timer 1 Mode 2
0607 758DF7     408            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
060A D28E       409            setb TR1
060C            410   
060C            411            ; Initialize the pin used by the ADC (P1.1) as input.
060C 43B302     412            orl     P1M1, #0b00000010
060F 53B4FD     413            anl     P1M2, #0b11111101
0612            414            
0612            415            ; Initialize and start the ADC:
0612 53E8F0     416            anl ADCCON0, #0xF0
0615 43E807     417            orl ADCCON0, #0x07 ; Select channel 7
0618            418            ; AINDIDS select if some pins are analog inputs or digital I/O:
0618 75F600     419            mov AINDIDS, #0x00 ; Disable all analog inputs
061B 43F680     420            orl AINDIDS, #0b10000000 ; P1.1 is analog input
061E 43E101     421            orl ADCCON1, #0x01 ; Enable ADC
0621            422            
0621            423            ; Initialize the Timers
0621 1203E7     424       lcall Timer0_Init ; Timer 1 (used to play noise from the speaker)
0624 12040A     425       lcall Timer2_Init ; Timer 2 (used to trigger an ISR every 1 second)
0627            426   
0627            427            ; Initialize the LCD - Toggle the 'E' pin
0627 1200FE     428       lcall LCD_4BIT ; Initialize the LCD display in 4 bit mode
062A            429            ;cpl TR0 ; toggle timer 0 immediately, or else it will make noise right away!
062A            430   
062A            431            ; Display the initial strings
062A C0E0       432            push acc
062C 7401       432            mov a, #1
062E 14         432            dec a
062F 12013E     432            lcall ?Set_Cursor_1 ; Select column and row
0632 D0E0       432            pop acc
0634 C083       433            push dph
0636 C082       433            push dpl
0638 C0E0       433            push acc
063A 90002E     433            mov dptr, #initial_msg1
063D 120131     433            lcall ?Send_Constant_String
0640 D0E0       433            pop acc
0642 D082       433            pop dpl
0644 D083       433            pop dph
0646            434   
0646 C0E0       435            push acc
0648 7401       435            mov a, #1
064A 14         435            dec a
064B 12013C     435            lcall ?Set_Cursor_2 ; Select column and row
064E D0E0       435            pop acc
0650 C083       436            push dph
0652 C082       436            push dpl
0654 C0E0       436            push acc
0656 90003F     436            mov dptr, #initial_mgs2
0659 120131     436            lcall ?Send_Constant_String
065C D0E0       436            pop acc
065E D082       436            pop dpl
0660 D083       436            pop dph
0662            437            
0662            438            ; Set the following variables to zero on startup
0662 7400       439            mov a, #0x0
0664            440            ;da a
0664 F53D       441            mov current_state, a
0666 F505       442            mov display_time, a
0668            443            ;mov current_soak_time, a
0668            444   
0668 7430       445            mov a, #0x30
066A            446            ;da a
066A F532       447            mov soak_temp, a
066C            448            
066C 75403C     449            mov x+0, #low (60 % 0x10000) 
066F 754100     449            mov x+1, #high(60 % 0x10000) 
0672 754200     449            mov x+2, #low (60 / 0x10000) 
0675 754300     449            mov x+3, #high(60 / 0x10000) 
0678 854033     450            mov soak_time+0, x+0
067B 854134     451            mov soak_time+1, x+1
067E 753500     452            mov soak_time+2, #0
0681 753600     453            mov soak_time+3, #0
0684            454   
0684            455            ;mov a, #0x200
0684            456            ;da a
0684 7540C8     457            mov x+0, #low (200 % 0x10000) 
0687 754100     457            mov x+1, #high(200 % 0x10000) 
068A 754200     457            mov x+2, #low (200 / 0x10000) 
068D 754300     457            mov x+3, #high(200 / 0x10000) 
0690 854037     458            mov reflow_temp+0, x+0
0693 854138     459            mov reflow_temp+1, x+1
0696 753900     460            mov reflow_temp+2, #0
0699 753A00     461            mov reflow_temp+3, #0
069C            462            ;mov reflow_temp, #0x200
069C            463   
069C 7445       464            mov a, #0x45
069E            465            ;da a
069E F539       466            mov reflow_time, a
06A0            467   
06A0            468   
06A0            469   ;;;;;;;;;;;;;;;;;;;;;;;;
06A0            470   ; FINITE STATE MACHINE ;
06A0            471   ;;;;;;;;;;;;;;;;;;;;;;;;
06A0            472   
06A0            473   ; Start of the finite state machine
06A0            474   
06A0            475   ; STATE 0 - Off State (power 0%)
06A0            476   off_state:
06A0            477   
06A0 E4         478            clr a    
06A1 D2CA       479            setb TR2 ; Start Timer 2
06A3 C28C       480            clr TR0 
06A5 753F00     481            mov pwm, #0 ; set the oven power to 0 in this state
06A8            482            
06A8 C207       483            clr cooling_done
06AA D206       484            setb new_state ; play sound out of the speaker 
06AC            485   
06AC            486            ; Display the initial strings
06AC C0E0       487            push acc
06AE 7401       487            mov a, #1
06B0 14         487            dec a
06B1 12013E     487            lcall ?Set_Cursor_1 ; Select column and row
06B4 D0E0       487            pop acc
06B6 C083       488            push dph
06B8 C082       488            push dpl
06BA C0E0       488            push acc
06BC 90002E     488            mov dptr, #initial_msg1
06BF 120131     488            lcall ?Send_Constant_String
06C2 D0E0       488            pop acc
06C4 D082       488            pop dpl
06C6 D083       488            pop dph
06C8            489   
06C8 C0E0       490            push acc
06CA 7401       490            mov a, #1
06CC 14         490            dec a
06CD 12013C     490            lcall ?Set_Cursor_2 ; Select column and row
06D0 D0E0       490            pop acc
06D2 C083       491            push dph
06D4 C082       491            push dpl
06D6 C0E0       491            push acc
06D8 90003F     491            mov dptr, #initial_mgs2
06DB 120131     491            lcall ?Send_Constant_String
06DE D0E0       491            pop acc
06E0 D082       491            pop dpl
06E2 D083       491            pop dph
06E4            492   
06E4            493            ; set the initial values on the screen
06E4 C0E0       494            push acc
06E6 7403       494            mov a, #3
06E8 14         494            dec a
06E9 12013C     494            lcall ?Set_Cursor_2 ; Select column and row
06EC D0E0       494            pop acc ; display the initial soak temperature
06EE C000       495            push ar0
06F0 A832       495            mov r0, soak_temp
06F2 120143     495            lcall ?Display_BCD
06F5 D000       495            pop ar0
06F7            496   
06F7 C0E0       497            push acc
06F9 7405       497            mov a, #5
06FB 14         497            dec a
06FC 12013C     497            lcall ?Set_Cursor_2 ; Select column and row
06FF D0E0       497            pop acc ; display the initial soak time
0701 853340     498            mov x+0, soak_time+0
0704 853441     499            mov x+1, soak_time+1
0707 754200     500            mov x+2, #0
070A 754300     501            mov x+3, #0
070D 120177     502            lcall hex2bcd
0710 C000       503            push ar0
0712 A849       503            mov r0, bcd+1
0714 120143     503            lcall ?Display_BCD
0717 D000       503            pop ar0
0719 C000       504            push ar0
071B A848       504            mov r0, bcd+0
071D 120143     504            lcall ?Display_BCD
0720 D000       504            pop ar0
0722 C0E0       505            push acc
0724 7405       505            mov a, #5
0726 14         505            dec a
0727 12013C     505            lcall ?Set_Cursor_2 ; Select column and row
072A D0E0       505            pop acc
072C C0E0       506            push acc
072E 742C       506            mov a, #','
0730 1200F4     506            lcall ?WriteData
0733 D0E0       506            pop acc
0735            507   
0735 C0E0       508            push acc
0737 740A       508            mov a, #10
0739 14         508            dec a
073A 12013C     508            lcall ?Set_Cursor_2 ; Select column and row
073D D0E0       508            pop acc
073F            508    ; display the initial reflow temperature
073F 853740     509            mov x+0, reflow_temp+0
0742 853841     510            mov x+1, reflow_temp+1
0745 754200     511            mov x+2, #0
0748 754300     512            mov x+3, #0
074B 120177     513            lcall hex2bcd
074E            514   
074E C000       515            push ar0
0750 A849       515            mov r0, bcd+1
0752 120143     515            lcall ?Display_BCD
0755 D000       515            pop ar0
0757 C000       516            push ar0
0759 A848       516            mov r0, bcd+0
075B 120143     516            lcall ?Display_BCD
075E D000       516            pop ar0
0760            517   
0760 C0E0       518            push acc
0762 740A       518            mov a, #10
0764 14         518            dec a
0765 12013C     518            lcall ?Set_Cursor_2 ; Select column and row
0768 D0E0       518            pop acc
076A C0E0       519            push acc
076C 7472       519            mov a, #'r'
076E 1200F4     519            lcall ?WriteData
0771 D0E0       519            pop acc
0773 C0E0       520            push acc
0775 740E       520            mov a, #14
0777 14         520            dec a
0778 12013C     520            lcall ?Set_Cursor_2 ; Select column and row
077B D0E0       520            pop acc
077D C0E0       521            push acc
077F 742C       521            mov a, #','
0781 1200F4     521            lcall ?WriteData
0784 D0E0       521            pop acc
0786            522   
0786 C0E0       523            push acc
0788 740F       523            mov a, #15
078A 14         523            dec a
078B 12013C     523            lcall ?Set_Cursor_2 ; Select column and row
078E D0E0       523            pop acc ; display the initial reflow time
0790 C000       524            push ar0
0792 A839       524            mov r0, reflow_time+0
0794 120143     524            lcall ?Display_BCD
0797 D000       524            pop ar0
0799            525   
0799            526            ; we first want the user to set the soak temperature
0799            527            soak_temp_button:
0799 120577     528            lcall LCD_PB ; check for pushbutton presses
079C 7A32       529            mov r2, #50
079E 1205CD     530            lcall waitms
07A1 120577     531            lcall LCD_PB 
07A4            532            
07A4 300008     533            jnb PB0, inc_soak_temp ; if the increment button is pressed
07A7 300112     534            jnb PB1, dec_soak_temp ; if the decrement button is pressed
07AA 300235     535            jnb PB2, soak_time_button ; if the next button is pressed
07AD 801E       536            sjmp display_soak_temp ; check button presses again
07AF            537   
07AF            538            inc_soak_temp:
07AF E532       539            mov a, soak_temp
07B1 2401       540            add a, #0x01
07B3 D4         541            da a
07B4 B47012     542            cjne a, #0x70, continue1
07B7 753230     543            mov soak_temp, #0x30
07BA 8011       544            sjmp display_soak_temp
07BC            545   
07BC            546            dec_soak_temp:
07BC E532       547            mov a, soak_temp
07BE 2499       548            add a, #0x99
07C0 D4         549            da a
07C1 B42905     550            cjne a, #0x29, continue1
07C4 753270     551            mov soak_temp, #0x70
07C7 8004       552            sjmp display_soak_temp
07C9            553   
07C9            554            continue1:
07C9 F532       555            mov soak_temp, a
07CB 8000       556            sjmp display_soak_temp
07CD            557            
07CD            558            display_soak_temp:
07CD C0E0       559            push acc
07CF 7403       559            mov a, #3
07D1 14         559            dec a
07D2 12013C     559            lcall ?Set_Cursor_2 ; Select column and row
07D5 D0E0       559            pop acc ; display the current soak temperature
07D7 C000       560            push ar0
07D9 A832       560            mov r0, soak_temp
07DB 120143     560            lcall ?Display_BCD
07DE D000       560            pop ar0
07E0 80B7       561            sjmp soak_temp_button
07E2            562   
07E2            563            ; next we want to user the set the soak time (in seconds)
07E2            564            soak_time_button:
07E2 120577     565            lcall LCD_PB ; check for pushbutton presses
07E5 7A32       566            mov r2, #50
07E7 1205CD     567            lcall waitms
07EA 120577     568            lcall LCD_PB
07ED            569            
07ED 300008     570            jnb PB0, inc_soak_time ; if the increment button is pressed
07F0 300109     571            jnb PB1, dec_soak_time ; if the decrement button is pressed
07F3 30024A     572            jnb PB2, reflow_temp_button ; if the next button is pressed
07F6 8008       573            sjmp display_soak_time ; check button presses again
07F8            574   
07F8            575            inc_soak_time:
07F8 0533       576            inc soak_time
07FA 8004       577            sjmp display_soak_time
07FC            578            
07FC            579            dec_soak_time:
07FC 1533       580            dec soak_time
07FE            581            ;mov soak_time, a
07FE            582            
07FE            583            continue2:
07FE            584            ;mov soak_time, a
07FE 8000       585            sjmp display_soak_time
0800            586   
0800            587            display_soak_time:
0800 C0E0       588            push acc
0802 7405       588            mov a, #5
0804 14         588            dec a
0805 12013C     588            lcall ?Set_Cursor_2 ; Select column and row
0808 D0E0       588            pop acc ; display the initial soak time
080A 853340     589            mov x+0, soak_time+0
080D 853441     590            mov x+1, soak_time+1
0810 754200     591            mov x+2, #0
0813 754300     592            mov x+3, #0
0816 120177     593            lcall hex2bcd
0819 C000       594            push ar0
081B A849       594            mov r0, bcd+1
081D 120143     594            lcall ?Display_BCD
0820 D000       594            pop ar0
0822 C000       595            push ar0
0824 A848       595            mov r0, bcd+0
0826 120143     595            lcall ?Display_BCD
0829 D000       595            pop ar0
082B C0E0       596            push acc
082D 7405       596            mov a, #5
082F 14         596            dec a
0830 12013C     596            lcall ?Set_Cursor_2 ; Select column and row
0833 D0E0       596            pop acc
0835 C0E0       597            push acc
0837 742C       597            mov a, #','
0839 1200F4     597            lcall ?WriteData
083C D0E0       597            pop acc
083E 80A2       598            sjmp soak_time_button
0840            599   
0840            600            ; third, we want the user to set the reflow temperature 
0840            601            reflow_temp_button:
0840 120577     602            lcall LCD_PB ; check for pushbutton presses
0843 7A32       603            mov r2, #50
0845 1205CD     604            lcall waitms
0848 120577     605            lcall LCD_PB
084B            606            
084B 300008     607            jnb PB0, inc_reflow_temp ; if the increment button is pressed
084E 300109     608            jnb PB1, dec_reflow_temp ; if the decrement button is pressed
0851 300263     609            jnb PB2, reflow_time_button ; if the next button is pressed
0854 80EA       610            sjmp reflow_temp_button ; check button presses again
0856            611   
0856            612            inc_reflow_temp:
0856            613            ;mov a, reflow_temp+0
0856            614            ;add a, #0x01
0856            615            ;da a
0856            616            ;cjne a, #0x50, continue3
0856            617            ;mov reflow_temp+0, #0x00
0856            618            ;mov reflow_temp+0, a
0856            619            
0856 0537       620            inc reflow_temp
0858 800A       621            sjmp display_reflow_temp
085A            622   
085A            623            dec_reflow_temp:
085A 1537       624            dec reflow_temp         
085C 8006       625            sjmp display_reflow_temp
085E            626   
085E            627            continue3:
085E F537       628            mov reflow_temp+0, a
0860 8002       629            sjmp display_reflow_temp
0862 F537       630            mov reflow_temp+0, a 
0864            631   
0864            632            display_reflow_temp:
0864            633            ;Set_Cursor(2,12) ; display the current reflow temperature
0864            634            ;Display_BCD(reflow_temp+0)
0864            635   
0864 C0E0       636            push acc
0866 740A       636            mov a, #10
0868 14         636            dec a
0869 12013C     636            lcall ?Set_Cursor_2 ; Select column and row
086C D0E0       636            pop acc ; display the initial reflow temperature
086E 853740     637            mov x+0, reflow_temp+0
0871 853841     638            mov x+1, reflow_temp+1
0874 754200     639            mov x+2, #0
0877 754300     640            mov x+3, #0
087A 120177     641            lcall hex2bcd
087D            642   
087D C000       643            push ar0
087F A849       643            mov r0, bcd+1
0881 120143     643            lcall ?Display_BCD
0884 D000       643            pop ar0
0886 C000       644            push ar0
0888 A848       644            mov r0, bcd+0
088A 120143     644            lcall ?Display_BCD
088D D000       644            pop ar0
088F            645   
088F C0E0       646            push acc
0891 740A       646            mov a, #10
0893 14         646            dec a
0894 12013C     646            lcall ?Set_Cursor_2 ; Select column and row
0897 D0E0       646            pop acc
0899 C0E0       647            push acc
089B 7472       647            mov a, #'r'
089D 1200F4     647            lcall ?WriteData
08A0 D0E0       647            pop acc
08A2 C0E0       648            push acc
08A4 740E       648            mov a, #14
08A6 14         648            dec a
08A7 12013C     648            lcall ?Set_Cursor_2 ; Select column and row
08AA D0E0       648            pop acc
08AC C0E0       649            push acc
08AE 742C       649            mov a, #','
08B0 1200F4     649            lcall ?WriteData
08B3 D0E0       649            pop acc
08B5            650   
08B5 8089       651            sjmp reflow_temp_button
08B7            652   
08B7            653            ; finally, we want the user to set the reflow time 
08B7            654            reflow_time_button:
08B7 120577     655            lcall LCD_PB ; check for pushbutton presses
08BA 7A32       656            mov r2, #50
08BC 1205CD     657            lcall waitms
08BF 120577     658            lcall LCD_PB
08C2            659            
08C2 300008     660            jnb PB0, inc_reflow_time ; if the increment button is pressed
08C5 300112     661            jnb PB1, dec_reflow_time ; if the decrement button is pressed
08C8 300237     662            jnb PB2, wait_for_start ; if the next button is pressed
08CB 80EA       663            sjmp reflow_time_button ; check button presses again
08CD            664   
08CD            665            inc_reflow_time:
08CD E539       666            mov a, reflow_time
08CF 2401       667            add a, #0x01
08D1 D4         668            da a
08D2 B48012     669            cjne a, #0x80, continue4
08D5 753940     670            mov reflow_time, #0x40
08D8 8013       671            sjmp display_reflow_time
08DA            672   
08DA            673            dec_reflow_time:
08DA E539       674            mov a, reflow_time
08DC 2499       675            add a, #0x99
08DE D4         676            da a
08DF B43905     677            cjne a, #0x39, continue4
08E2 753980     678            mov reflow_time, #0x80
08E5 8006       679            sjmp display_reflow_time
08E7            680   
08E7            681            continue4:
08E7 F539       682            mov reflow_time, a
08E9 8002       683            sjmp display_reflow_time
08EB F539       684            mov reflow_time, a 
08ED            685   
08ED            686            display_reflow_time:
08ED C0E0       687            push acc
08EF 740F       687            mov a, #15
08F1 14         687            dec a
08F2 12013C     687            lcall ?Set_Cursor_2 ; Select column and row
08F5 D0E0       687            pop acc ; display the current reflow time
08F7 C000       688            push ar0
08F9 A839       688            mov r0, reflow_time
08FB 120143     688            lcall ?Display_BCD
08FE D000       688            pop ar0
0900 80B5       689            sjmp reflow_time_button 
0902            690   
0902            691            ; if we reach this label, all paramters have been set
0902            692            ; we are now waiting for the user to press the start/stop button (PB4) to begin
0902            693            wait_for_start:
0902 120577     694            lcall LCD_PB ; check for pushbuttons presses
0905 7A32       695            mov r2, #50
0907 1205CD     696            lcall waitms
090A 120577     697            lcall LCD_PB
090D 2004F2     698            jb PB4, wait_for_start ; infinite loop if the start button is not pressed
0910 020913     699            ljmp preheat_state
0913            700            ;mov current_state, #1 ; if the start button is pressed, move to state 1 (preheat)
0913            701   
0913            702   ; STATE 1 - Preheat State (increase temperature to soak_temp - power 100%), check for it to reach over 50 C within 60 seconds
0913            703   preheat_state:
0913            704   
0913 020B47     705            ljmp reflow_state
0916            706   
0916 E4         707            clr a 
0917 7401       708            mov a, #0x01
0919 1200F9     708            lcall ?WriteCommand ; clear the LCD
091C 7A02       709            mov R2, #2
091E 1205CD     710            lcall waitms
0921 C0E0       711            push acc
0923 7401       711            mov a, #1
0925 14         711            dec a
0926 12013E     711            lcall ?Set_Cursor_1 ; Select column and row
0929 D0E0       711            pop acc
092B C083       712            push dph
092D C082       712            push dpl
092F C0E0       712            push acc
0931 90002E     712            mov dptr, #initial_msg1
0934 120131     712            lcall ?Send_Constant_String
0937 D0E0       712            pop acc
0939 D082       712            pop dpl
093B D083       712            pop dph
093D 753F64     713            mov pwm, #100 ; set the oven power to 100% in this state
0940            714   
0940 D206       715            setb new_state
0942 E532       716            mov a, soak_temp
0944 2451       717            add a, #81
0946 F532       718            mov soak_temp, a
0948            719   
0948            720            ; display the working message string
0948 C0E0       721            push acc
094A 7401       721            mov a, #1
094C 14         721            dec a
094D 12013C     721            lcall ?Set_Cursor_2 ; Select column and row
0950 D0E0       721            pop acc
0952 C083       722            push dph
0954 C082       722            push dpl
0956 C0E0       722            push acc
0958 900050     722            mov dptr, #preheat_mgs
095B 120131     722            lcall ?Send_Constant_String
095E D0E0       722            pop acc
0960 D082       722            pop dpl
0962 D083       722            pop dph
0964            723   
0964            724            ; reset the state_time
0964 E4         725            clr a
0965 753C00     726            mov state_time, #0x00
0968            727   
0968            728            ; check if the current temperature is equal to the user set soak temperature
0968            729            check_soak_temp:
0968            730            ; every 1 second, update the display
0968 300944     731            jnb one_second_flag, read_soak_temp
096B 1204B5     732            lcall Read_Temp
096E E53C       733            mov a, state_time
0970 2401       734            add a, #0x01
0972 D4         735            da a 
0973 F53C       736            mov state_time, a 
0975 C0E0       737            push acc
0977 7403       737            mov a, #3
0979 14         737            dec a
097A 12013C     737            lcall ?Set_Cursor_2 ; Select column and row
097D D0E0       737            pop acc
097F            737   
097F C000       738            push ar0
0981 A83C       738            mov r0, state_time
0983 120143     738            lcall ?Display_BCD
0986 D000       738            pop ar0
0988 C000       739            push ar0
098A A84A       739            mov r0, bcd+2
098C 120161     739            lcall ?Send_BCD
098F D000       739            pop ar0
0991            740            ; write decimal point
0991 742E       741       mov a, #0x2E ; ASCII for '.'
0993 120159     742       lcall putchar
0996 C000       743            push ar0
0998 A849       743            mov r0, bcd+1
099A 120161     743            lcall ?Send_BCD
099D D000       743            pop ar0
099F C000       744            push ar0
09A1 A848       744            mov r0, bcd+0
09A3 120161     744            lcall ?Send_BCD
09A6 D000       744            pop ar0
09A8            745            ; write newline character
09A8 740A       746       mov a, #0x0A
09AA 120159     747       lcall putchar
09AD C209       748            clr one_second_flag
09AF            749   
09AF            750            read_soak_temp:
09AF            751            ; move the soak_temp variable to y
09AF 853244     752            mov y+0, soak_temp
09B2 754500     753            mov y+1, #0
09B5 754600     754            mov y+2, #0
09B8 754700     755            mov y+3, #0
09BB            756   
09BB            757            ; compare x and y (current temperature vs soak temperature)
09BB 12029B     758            lcall x_gt_y ; sets the mf bit if x > y
09BE 200825     759            jb mf, soak_state ; if we have reached the soak_temp, check for an error 
09C1            760   
09C1            761            ; check if the current temperature is less than 50 degrees
09C1            762            check_for_error:
09C1 754432     763            mov y+0, #low (50 % 0x10000) 
09C4 754500     763            mov y+1, #high(50 % 0x10000) 
09C7 754600     763            mov y+2, #low (50 / 0x10000) 
09CA 754700     763            mov y+3, #high(50 / 0x10000) 
09CD 12029B     764            lcall x_gt_y ; check if the current temperature is greater than 50 degrees
09D0 20080A     765            jb mf, soak_not_reached ; if we are over 50 degrees, check the temperature again
09D3            766   
09D3            767            ; if the current temperature is less than 50 degrees, check the state time
09D3            768            error: 
09D3 7E00       769            mov R6, #0
09D5 AE3C       770            mov R6, state_time
09D7 BE6003     771            cjne R6, #0x60, soak_not_reached ; if less than 60 seconds have passed, we have not reached the termination condition
09DA 0206A0     772            ljmp off_state ; if at least 60 seconds have passed, we must terminate the program 
09DD            773   
09DD            774            ; if we are not ready to procede to soak, check the stop button
09DD            775            soak_not_reached:
09DD 120577     776            lcall LCD_PB ; check for pushbutton presses
09E0 200485     777            jb PB4, check_soak_temp 
09E3 0206A0     778            ljmp off_state
09E6            779   
09E6            780   
09E6            781   ; STATE 2 - Soak State (maintain temperature - power 20%)
09E6            782   soak_state: 
09E6            783            
09E6 E4         784            clr a
09E7 7401       785            mov a, #0x01
09E9 1200F9     785            lcall ?WriteCommand ; clear the LCD
09EC 7A02       786            mov R2, #2
09EE 1205CD     787            lcall waitms
09F1 C0E0       788            push acc
09F3 7401       788            mov a, #1
09F5 14         788            dec a
09F6 12013E     788            lcall ?Set_Cursor_1 ; Select column and row
09F9 D0E0       788            pop acc
09FB C083       789            push dph
09FD C082       789            push dpl
09FF C0E0       789            push acc
0A01 90002E     789            mov dptr, #initial_msg1
0A04 120131     789            lcall ?Send_Constant_String
0A07 D0E0       789            pop acc
0A09 D082       789            pop dpl
0A0B D083       789            pop dph
0A0D 753F14     790            mov pwm, #20 ; set the oven power to 100% in this state
0A10 D206       791            setb new_state
0A12            792            
0A12            793            ; display the working message string
0A12 C0E0       794            push acc
0A14 7401       794            mov a, #1
0A16 14         794            dec a
0A17 12013C     794            lcall ?Set_Cursor_2 ; Select column and row
0A1A D0E0       794            pop acc
0A1C C083       795            push dph
0A1E C082       795            push dpl
0A20 C0E0       795            push acc
0A22 900061     795            mov dptr, #soak_mgs
0A25 120131     795            lcall ?Send_Constant_String
0A28 D0E0       795            pop acc
0A2A D082       795            pop dpl
0A2C D083       795            pop dph
0A2E            796   
0A2E            797            ; reset the state_time
0A2E E4         798            clr a
0A2F F53C       799            mov state_time, a
0A31            800   
0A31            801            check_soak_time:
0A31            802            ; every 1 second, update the display
0A31 300944     803            jnb one_second_flag, read_soak_time
0A34 1204B5     804            lcall Read_Temp ; read the current temperature - store result in x
0A37 E53C       805            mov a, state_time
0A39 2401       806            add a, #0x01
0A3B D4         807            da a 
0A3C F53C       808            mov state_time, a
0A3E C0E0       809            push acc
0A40 7403       809            mov a, #3
0A42 14         809            dec a
0A43 12013C     809            lcall ?Set_Cursor_2 ; Select column and row
0A46 D0E0       809            pop acc
0A48 C000       810            push ar0
0A4A A83C       810            mov r0, state_time
0A4C 120143     810            lcall ?Display_BCD
0A4F D000       810            pop ar0
0A51 C000       811            push ar0
0A53 A84A       811            mov r0, bcd+2
0A55 120161     811            lcall ?Send_BCD
0A58 D000       811            pop ar0
0A5A            812            ; write decimal point
0A5A 742E       813       mov a, #0x2E ; ASCII for '.'
0A5C 120159     814       lcall putchar
0A5F C000       815            push ar0
0A61 A849       815            mov r0, bcd+1
0A63 120161     815            lcall ?Send_BCD
0A66 D000       815            pop ar0
0A68 C000       816            push ar0
0A6A A848       816            mov r0, bcd+0
0A6C 120161     816            lcall ?Send_BCD
0A6F D000       816            pop ar0
0A71            817            ; write newline character
0A71 740A       818       mov a, #0x0A
0A73 120159     819       lcall putchar
0A76 C209       820            clr one_second_flag
0A78            821   
0A78            822            read_soak_time:
0A78 853340     823            mov x+0, soak_time
0A7B 754100     824            mov x+1, #0
0A7E 754200     825            mov x+2, #0
0A81 754300     826            mov x+3, #0
0A84            827   
0A84 120177     828            lcall hex2bcd
0A87 E548       829            mov a, bcd+0
0A89            830            
0A89 B53C02     831            cjne a, state_time, soak_time_not_reached
0A8C 8009       832            sjmp ramp_state
0A8E            833   
0A8E            834            soak_time_not_reached:
0A8E 120577     835            lcall LCD_PB ; check for pushbutton presses
0A91 20049D     836            jb PB4, check_soak_time 
0A94 0206A0     837            ljmp off_state
0A97            838   
0A97            839   ; STATE 3 - Ramp to Reflow State (increase temperature to reflow_temp - power 100%)
0A97            840   ramp_state:
0A97            841   
0A97 E4         842            clr a 
0A98 7401       843            mov a, #0x01
0A9A 1200F9     843            lcall ?WriteCommand ; clear the LCD
0A9D 7A02       844            mov R2, #2
0A9F 1205CD     845            lcall waitms
0AA2            846   
0AA2 C0E0       847            push acc
0AA4 7401       847            mov a, #1
0AA6 14         847            dec a
0AA7 12013E     847            lcall ?Set_Cursor_1 ; Select column and row
0AAA D0E0       847            pop acc
0AAC C083       848            push dph
0AAE C082       848            push dpl
0AB0 C0E0       848            push acc
0AB2 90002E     848            mov dptr, #initial_msg1
0AB5 120131     848            lcall ?Send_Constant_String
0AB8 D0E0       848            pop acc
0ABA D082       848            pop dpl
0ABC D083       848            pop dph
0ABE 753F64     849            mov pwm, #100 ; set the oven power to 100% in this state
0AC1            850            
0AC1            851            ; reset the state_time
0AC1 E4         852            clr a
0AC2 F53C       853            mov state_time, a
0AC4            854   
0AC4 D206       855            setb new_state
0AC6            856            ; display the working message string
0AC6 C0E0       857            push acc
0AC8 7401       857            mov a, #1
0ACA 14         857            dec a
0ACB 12013C     857            lcall ?Set_Cursor_2 ; Select column and row
0ACE D0E0       857            pop acc
0AD0 C083       858            push dph
0AD2 C082       858            push dpl
0AD4 C0E0       858            push acc
0AD6 900072     858            mov dptr, #ramp_mgs
0AD9 120131     858            lcall ?Send_Constant_String
0ADC D0E0       858            pop acc
0ADE D082       858            pop dpl
0AE0 D083       858            pop dph
0AE2            859   
0AE2            860            ; reading the ramp temperature to determine if we should enter
0AE2            861            ; reflow
0AE2            862            check_ramp_temp:
0AE2            863            ; every 1 second, update the display
0AE2 300944     864            jnb one_second_flag, read_ramp_temp
0AE5 1204B5     865            lcall Read_Temp ; read the current temperature - store result in x
0AE8 E53C       866            mov a, state_time
0AEA 2401       867            add a, #0x01
0AEC D4         868            da a 
0AED F53C       869            mov state_time, a
0AEF C0E0       870            push acc
0AF1 7403       870            mov a, #3
0AF3 14         870            dec a
0AF4 12013C     870            lcall ?Set_Cursor_2 ; Select column and row
0AF7 D0E0       870            pop acc
0AF9 C000       871            push ar0
0AFB A83C       871            mov r0, state_time
0AFD 120143     871            lcall ?Display_BCD
0B00 D000       871            pop ar0
0B02 C000       872            push ar0
0B04 A84A       872            mov r0, bcd+2
0B06 120161     872            lcall ?Send_BCD
0B09 D000       872            pop ar0
0B0B            873            ; write decimal point
0B0B 742E       874       mov a, #0x2E ; ASCII for '.'
0B0D 120159     875       lcall putchar
0B10 C000       876            push ar0
0B12 A849       876            mov r0, bcd+1
0B14 120161     876            lcall ?Send_BCD
0B17 D000       876            pop ar0
0B19 C000       877            push ar0
0B1B A848       877            mov r0, bcd+0
0B1D 120161     877            lcall ?Send_BCD
0B20 D000       877            pop ar0
0B22            878            ; write newline character
0B22 740A       879       mov a, #0x0A
0B24 120159     880       lcall putchar
0B27 C209       881            clr one_second_flag
0B29            882   
0B29            883            read_ramp_temp:
0B29            884            ; moving the reflow temp value into y
0B29 853744     885            mov y+0, reflow_temp+0
0B2C 853845     886            mov y+1, reflow_temp+1
0B2F 754600     887            mov y+2, #0
0B32 754700     888            mov y+3, #0
0B35            889   
0B35            890            ; check if the current temperature is equal to the user set soak temperature
0B35 12029B     891            lcall x_gt_y
0B38 20080C     892            jb mf, reflow_state
0B3B            893   
0B3B            894            ; if we are not ready to procede to reflow, check the stop button
0B3B            895            reflow_not_reached:
0B3B 120577     896            lcall LCD_PB ; check for pushbutton presses
0B3E 2004A1     897            jb PB4, check_ramp_temp 
0B41 753D00     898            mov current_state, #0 ; if the stop button is pressed, return to state 0
0B44 0206A0     899            ljmp off_state
0B47            900   
0B47            901   
0B47            902   ; STATE 4 - Reflow State (maintain temperature - power 20%)
0B47            903   reflow_state:
0B47            904   
0B47 E4         905            clr a 
0B48 7401       906            mov a, #0x01
0B4A 1200F9     906            lcall ?WriteCommand ; clear the LCD
0B4D 7A02       907            mov R2, #2
0B4F 1205CD     908            lcall waitms
0B52            909   
0B52 C0E0       910            push acc
0B54 7401       910            mov a, #1
0B56 14         910            dec a
0B57 12013E     910            lcall ?Set_Cursor_1 ; Select column and row
0B5A D0E0       910            pop acc
0B5C C083       911            push dph
0B5E C082       911            push dpl
0B60 C0E0       911            push acc
0B62 90002E     911            mov dptr, #initial_msg1
0B65 120131     911            lcall ?Send_Constant_String
0B68 D0E0       911            pop acc
0B6A D082       911            pop dpl
0B6C D083       911            pop dph
0B6E 753F14     912            mov pwm, #20 ; set the oven power to 20% in this state
0B71            913            
0B71 D206       914            setb new_state
0B73            915            ; display the working message string
0B73 C0E0       916            push acc
0B75 7401       916            mov a, #1
0B77 14         916            dec a
0B78 12013C     916            lcall ?Set_Cursor_2 ; Select column and row
0B7B D0E0       916            pop acc
0B7D C083       917            push dph
0B7F C082       917            push dpl
0B81 C0E0       917            push acc
0B83 900083     917            mov dptr, #reflow_mgs
0B86 120131     917            lcall ?Send_Constant_String
0B89 D0E0       917            pop acc
0B8B D082       917            pop dpl
0B8D D083       917            pop dph
0B8F            918   
0B8F            919            ; reset the state_time
0B8F E4         920            clr a
0B90 F53C       921            mov state_time, a
0B92            922   
0B92            923            check_reflow_time:
0B92            924            ; every 1 second, update the display
0B92 300944     925            jnb one_second_flag, read_reflow_time
0B95 1204B5     926            lcall Read_Temp ; read the current temperature - store result in x
0B98 E53C       927            mov a, state_time
0B9A 2401       928            add a, #0x01
0B9C D4         929            da a 
0B9D F53C       930            mov state_time, a
0B9F C0E0       931            push acc
0BA1 7403       931            mov a, #3
0BA3 14         931            dec a
0BA4 12013C     931            lcall ?Set_Cursor_2 ; Select column and row
0BA7 D0E0       931            pop acc
0BA9 C000       932            push ar0
0BAB A83C       932            mov r0, state_time
0BAD 120143     932            lcall ?Display_BCD
0BB0 D000       932            pop ar0
0BB2 C000       933            push ar0
0BB4 A84A       933            mov r0, bcd+2
0BB6 120161     933            lcall ?Send_BCD
0BB9 D000       933            pop ar0
0BBB            934            ; write decimal point
0BBB 742E       935       mov a, #0x2E ; ASCII for '.'
0BBD 120159     936       lcall putchar
0BC0 C000       937            push ar0
0BC2 A849       937            mov r0, bcd+1
0BC4 120161     937            lcall ?Send_BCD
0BC7 D000       937            pop ar0
0BC9 C000       938            push ar0
0BCB A848       938            mov r0, bcd+0
0BCD 120161     938            lcall ?Send_BCD
0BD0 D000       938            pop ar0
0BD2            939            ; write newline character
0BD2 740A       940       mov a, #0x0A
0BD4 120159     941       lcall putchar
0BD7 C209       942            clr one_second_flag
0BD9            943            
0BD9            944            read_reflow_time:
0BD9 E539       945            mov a, reflow_time
0BDB B53C02     946            cjne a, state_time, reflow_time_not_reached
0BDE 8009       947            sjmp cooling_state
0BE0            948   
0BE0            949            reflow_time_not_reached:
0BE0 120577     950            lcall LCD_PB ; check for pushbutton presses
0BE3 2004AC     951            jb PB4, check_reflow_time 
0BE6 0206A0     952            ljmp off_state
0BE9            953   
0BE9            954   
0BE9            955   cooling_state:
0BE9            956   
0BE9 E4         957            clr a 
0BEA 7401       958            mov a, #0x01
0BEC 1200F9     958            lcall ?WriteCommand ; clear the LCD
0BEF 7A02       959            mov R2, #2
0BF1 1205CD     960            lcall waitms
0BF4            961   
0BF4 C0E0       962            push acc
0BF6 7401       962            mov a, #1
0BF8 14         962            dec a
0BF9 12013E     962            lcall ?Set_Cursor_1 ; Select column and row
0BFC D0E0       962            pop acc
0BFE C083       963            push dph
0C00 C082       963            push dpl
0C02 C0E0       963            push acc
0C04 90002E     963            mov dptr, #initial_msg1
0C07 120131     963            lcall ?Send_Constant_String
0C0A D0E0       963            pop acc
0C0C D082       963            pop dpl
0C0E D083       963            pop dph
0C10 753F00     964            mov pwm, #0 ; set the oven power to 100% in this state
0C13            965            
0C13            966            ; reset the state_time
0C13 E4         967            clr a
0C14 F53C       968            mov state_time, a
0C16            969   
0C16 D206       970            setb new_state
0C18            971            ; display the working message string
0C18 C0E0       972            push acc
0C1A 7401       972            mov a, #1
0C1C 14         972            dec a
0C1D 12013C     972            lcall ?Set_Cursor_2 ; Select column and row
0C20 D0E0       972            pop acc
0C22 C083       973            push dph
0C24 C082       973            push dpl
0C26 C0E0       973            push acc
0C28 900094     973            mov dptr, #cooling_mgs
0C2B 120131     973            lcall ?Send_Constant_String
0C2E D0E0       973            pop acc
0C30 D082       973            pop dpl
0C32 D083       973            pop dph
0C34            974   
0C34            975            ; reading the ramp temperature to determine if we should enter
0C34            976            ; reflow
0C34            977            check_cooling_temp:
0C34            978            ; every 1 second, update the display
0C34 300944     979            jnb one_second_flag, read_cooling_temp
0C37 1204B5     980            lcall Read_Temp ; read the current temperature - store result in x
0C3A E53C       981            mov a, state_time
0C3C 2401       982            add a, #0x01
0C3E D4         983            da a 
0C3F F53C       984            mov state_time, a
0C41 C0E0       985            push acc
0C43 7403       985            mov a, #3
0C45 14         985            dec a
0C46 12013C     985            lcall ?Set_Cursor_2 ; Select column and row
0C49 D0E0       985            pop acc
0C4B            985   
0C4B C000       986            push ar0
0C4D A83C       986            mov r0, state_time
0C4F 120143     986            lcall ?Display_BCD
0C52 D000       986            pop ar0
0C54 C000       987            push ar0
0C56 A84A       987            mov r0, bcd+2
0C58 120161     987            lcall ?Send_BCD
0C5B D000       987            pop ar0
0C5D            988            ; write decimal point
0C5D 742E       989       mov a, #0x2E ; ASCII for '.'
0C5F 120159     990       lcall putchar
0C62 C000       991            push ar0
0C64 A849       991            mov r0, bcd+1
0C66 120161     991            lcall ?Send_BCD
0C69 D000       991            pop ar0
0C6B C000       992            push ar0
0C6D A848       992            mov r0, bcd+0
0C6F 120161     992            lcall ?Send_BCD
0C72 D000       992            pop ar0
0C74            993            ; write newline character
0C74 740A       994       mov a, #0x0A
0C76 120159     995       lcall putchar
0C79 C209       996            clr one_second_flag
0C7B            997   
0C7B            998            read_cooling_temp:
0C7B 75443C     999            mov y+0, #low (60 % 0x10000) 
0C7E 754500     999            mov y+1, #high(60 % 0x10000) 
0C81 754600     999            mov y+2, #low (60 / 0x10000) 
0C84 754700     999            mov y+3, #high(60 / 0x10000) 
0C87           1000            ; check if the current temperature is equal to the user set soak temperature
0C87 12027F    1001            lcall x_lt_y ; mf = 1 if x < y  
0C8A 200809    1002            jb mf, jumper
0C8D           1003   
0C8D           1004            ; if we are not ready to procede to reflow, check the stop button
0C8D           1005            cooling_not_reached:
0C8D 120577    1006            lcall LCD_PB ; check for pushbutton presses
0C90 2004A1    1007            jb PB4, check_cooling_temp 
0C93 753D00    1008            mov current_state, #0 ; if the stop button is pressed, return to state 0
0C96           1009   
0C96           1010            jumper:
0C96 0206A0    1011            ljmp off_state
0C99           1012   
0C99           1013   EN
