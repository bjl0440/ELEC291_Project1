0000              1   ; Implementation of the finite state machine to control the stages of the reflow oven
0000              2   
                  4   $LIST
0000              6   
0000              7   ;  N76E003 pinout:
0000              8   ;                               -------
0000              9   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             10   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             11   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             12   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             13   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             14   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             15   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             16   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             17   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             18   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             19   ;                               -------
0000             20   ;
0000             21   
0000             22   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD          EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER0_RATE   EQU 2048     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             25   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             27   TIMER2_RATE   EQU 100      ; 100Hz or 10ms
0000             28   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 2 input divide to 16 in T2MOD
0000             29   
0000             30   ; Relevant vectors
0000             31   ; Reset vector
0000             32   org 0x0000
0000 020622      33       ljmp initialize
0003             34   
0003             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 0203FD      37            ljmp Timer0_ISR
000E             38   
000E             39   ; Timer/Counter 2 overflow interrupt vector
002B             40   org 0x002B
002B 020427      41            ljmp Timer2_ISR
002E             42            
002E             43            
002E             44   ;;;;;;;;;;;;
002E             45   ;   PINS   ;
002E             46   ;;;;;;;;;;;;
002E             47      
002E             48   LCD_RS     equ P1.3
002E             49   ;LCD_RW    equ PX.X  ; Not used in this code, connect the pin to GND
002E             50   LCD_E      equ P1.4
002E             51   LCD_D4     equ P0.0
002E             52   LCD_D5     equ P0.1
002E             53   LCD_D6     equ P0.2
002E             54   LCD_D7     equ P0.3   
002E             55   PWM_OUT    equ P1.0 ; Toggles power to the oven (Logic 1=oven on)
002E             56   SOUND_OUT  equ P0.4 ; Speaker connection 
002E             57   
002E             58   ; Decleration of one byte current state variable and parameters
0030             59   DSEG at 0x30
0030             60   Count1ms:      ds 2 ; Used to determine when a second has passed
0032             61   soak_temp:     ds 2 ; User set variable for the desired soak temperature
0034             62   soak_time:     ds 2 ; User set variable for the length of the soak time
0036             63   reflow_temp:   ds 2 ; User set variable for the reflow temperature
0038             64   reflow_time:   ds 1 ; User set variable for timein the reflow state
0039             65   current_temp:  ds 1 ; Current temperature in the oven
003A             66   state_time:    ds 1 ; Current amount of time we have been in a given state
003B             67   current_state: ds 1 ; Current state of the finite state machine
003C             68   pwm_counter:   ds 1 ; Free running counter 0, 1, 2, ..., 100, 0 used for PWM purposes
003D             69   pwm:           ds 1 ; pwm percentage variable - adjust as needed in each state
003E             70   
003E             71   ;for math_32.inc library
003E             72   x:   ds 4
0042             73   y:   ds 4
0046             74   bcd: ds 5
004B             75   
004B             76   ; decleration of one bit variables (flags)
0000             77   BSEG
0000             78   ; These one bit variables store the value of the pushbuttons after calling 'LCD_PB' 
0000             79   PB0:                dbit 1 ; incremement (INC)
0001             80   PB1:                dbit 1 ; decremement (DEC)
0002             81   PB2:                dbit 1 ; next parameter (NXT)
0003             82   PB3:                dbit 1 ; currently unused (PB3)
0004             83   PB4:                dbit 1 ; start / emergency stop (EMR)
0005             84   display_time:  dbit 1 ; if this flag is set, we want to start displaying the state time
0006             85   next_state:    dbit 1 ; if this flag is set, we want to make a speaker beep
0007             86   cooling_done:  dbit 1 ; flag set if cooling state is finished
0008             87   mf:            dbit 1 ; used for math functions  
0009             88   
002E             89   CSEG
002E             90   
002E             91   ; Strings
002E             92   ;                '1234567890123456'
002E 546F3D20    93   initial_msg1: DB 'To=   C  Tj=  C ',0
     20204320
     20546A3D
     20204320
     00
003F 73312020    94   initial_mgs2: DB 's1  ,   r2  ,   ',0
     2C202020
     72322020
     2C202020
     00
0050             95   ;         s=soak temp, soak time   r=reflow temp,reflow time
0050             96   
0050             97   ;state name messages
0050             98   ;                '1234567890123456'
0050 743D2020    99   preheat_mgs: DB    't=       Preheat',0
     20202020
     20507265
     68656174
     00
0061 743D2020   100   soak_mgs:    DB    't=       Soaking',0
     20202020
     20536F61
     6B696E67
     00
0072 743D2020   101   ramp_mgs:    DB    't=          Ramp',0
     20202020
     20202020
     52616D70
     00
0083 743D2020   102   reflow_mgs:  DB    't=        Reflow',0
     20202020
     20205265
     666C6F77
     00
0094 743D2020   103   cooling_mgs: DB    't=       Cooling',0
     20202020
     20436F6F
     6C696E67
     00
00A5            104   
00A5            105   
00A5            106   ; A library of LCD related functions and utility macros
                108   $LIST
0159            110   
0159            111   ; A library of math related functions and utility macros
                579   $LIST
                113   $LIST
03E7            115   
03E7            116   ; Initialization of timers
03E7            117   ;---------------------------------;
03E7            118   ; Routine to initialize the ISR   ;
03E7            119   ; for timer 0                     ;
03E7            120   ;---------------------------------;
03E7            121   Timer0_Init:
03E7 438E08     122            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03EA E589       123            mov a, TMOD
03EC 54F0       124            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03EE 4401       125            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03F0 F589       126            mov TMOD, a
03F2 758CE0     127            mov TH0, #high(TIMER0_RELOAD)
03F5 758A57     128            mov TL0, #low(TIMER0_RELOAD)
03F8            129            ; Enable the timer and interrupts
03F8 D2A9       130       setb ET0  ; Enable timer 0 interrupt
03FA D28C       131       setb TR0  ; Start timer 0
03FC 22         132            ret
03FD            133   
03FD            134   ;---------------------------------;
03FD            135   ; ISR for timer 0.  Set to execute;
03FD            136   ; every 1/2048Hz to generate a    ;
03FD            137   ; 2048 Hz wave at pin SOUND_OUT   ;
03FD            138   ;---------------------------------;
03FD            139   Timer0_ISR:
03FD            140            ;clr TF0  ; According to the data sheet this is done for us already.
03FD            141            ; Timer 0 doesn't have 16-bit auto-reload, so
03FD C28C       142            clr TR0
03FF 758CE0     143            mov TH0, #high(TIMER0_RELOAD)
0402 758A57     144            mov TL0, #low(TIMER0_RELOAD)
0405 D28C       145            setb TR0
0407 B284       146            cpl SOUND_OUT ; Toggles the speaker pin at 1000 Hz to play noise
0409 32         147            reti
040A            148   
040A            149   ;---------------------------------;
040A            150   ; Routine to initialize the ISR   ;
040A            151   ; for timer 2                     ;
040A            152   ;---------------------------------;
040A            153   Timer2_Init:
040A            154            ; Initialize timer 2 for periodic interrupts
040A 75C800     155            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
040D 75CDD7     156            mov TH2, #high(TIMER2_RELOAD)
0410 75CC79     157            mov TL2, #low(TIMER2_RELOAD)
0413            158            ; Set the reload value
0413 75C9A0     159            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0416 75CBD7     160            mov RCMP2H, #high(TIMER2_RELOAD)
0419 75CA79     161            mov RCMP2L, #low(TIMER2_RELOAD)
041C            162            ; Init the free running 10 ms counter to zero
041C 753C00     163            mov pwm_counter, #0
041F            164            ; Enable the timer and interrupts
041F 439B80     165            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0422 D2CA       166       setb TR2  ; Enable timer 2
0424 D2AF       167            setb EA ; Enable global interrupts
0426            168   
0426 22         169            ret 
0427            170   
0427            171   ;---------------------------------;
0427            172   ; ISR for timer 2                 ;
0427            173   ;---------------------------------;
0427            174   Timer2_ISR:
0427 C2CF       175            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0429 C0D0       176            push psw
042B C0E0       177            push acc
042D            178            
042D 053C       179            inc pwm_counter
042F C3         180            clr c
0430 E53D       181            mov a, pwm
0432 953C       182            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0434 B3         183            cpl c
0435 9290       184            mov PWM_OUT, c
0437            185            
0437 E53C       186            mov a, pwm_counter
0439 B4642E     187            cjne a, #100, Timer2_ISR_done ; check if 1000 ms have passed
043C 753C00     188            mov pwm_counter, #0
043F 053A       189            inc state_time ; It is super easy to keep a seconds count here
0441            190   
0441 300513     191            jnb display_time, new_state_noise ; if we are in at least the pre-heat state, begin showing state time on the LCD       Set_Cursor(2,3)
0444 C0E0       192            push acc
0446 7403       192            mov a, #3
0448 14         192            dec a
0449 12013C     192            lcall ?Set_Cursor_2 ; Select column and row
044C D0E0       192            pop acc
044E            192   
044E C000       193            push ar0
0450 A83A       193            mov r0, state_time
0452 120143     193            lcall ?Display_BCD
0455 D000       193            pop ar0
0457            194   
0457            195            new_state_noise:
0457 300607     196            jnb next_state, send_serial ; if we are not entering a new state, jump to the send serial port code
045A B28C       197            cpl TR0 ; Enable/disable timer/counter 0. This line enables the beep sound from the speaker when we enter a new state
045C 200702     198            jb cooling_done, send_serial ; if cooling is done, we play the sound 3 times
045F C206       199            clr next_state
0461            200   
0461            201            send_serial:
0461 C000       202            push ar0
0463 A83E       202            mov r0, x
0465 120161     202            lcall ?Send_BCD
0468 D000       202            pop ar0 ; Assuming the current temperature is stored in a byte of x
046A            203   
046A            204   Timer2_ISR_done:
046A D0E0       205            pop acc
046C D0D0       206            pop psw
046E 32         207            reti
046F            208   
046F            209   ; Function declearations begins here:
046F            210   ; We can display a number any way we want.  In this case with four decimal places.
046F            211   Display_formated_BCD:
046F C0E0       212            push acc
0471 7405       212            mov a, #5
0473 14         212            dec a
0474 12013C     212            lcall ?Set_Cursor_2 ; Select column and row
0477 D0E0       212            pop acc
0479 C000       213            push ar0
047B A84A       213            mov r0, bcd+4
047D 120143     213            lcall ?Display_BCD
0480 D000       213            pop ar0
0482 C000       214            push ar0
0484 A849       214            mov r0, bcd+3
0486 120143     214            lcall ?Display_BCD
0489 D000       214            pop ar0
048B C000       215            push ar0
048D A848       215            mov r0, bcd+2
048F 120143     215            lcall ?Display_BCD
0492 D000       215            pop ar0
0494            216            ;Display_char(#'.')
0494 C000       217            push ar0
0496 A847       217            mov r0, bcd+1
0498 120143     217            lcall ?Display_BCD
049B D000       217            pop ar0
049D C000       218            push ar0
049F A846       218            mov r0, bcd+0
04A1 120143     218            lcall ?Display_BCD
04A4 D000       218            pop ar0
04A6 C0E0       219            push acc
04A8 7406       219            mov a, #6
04AA 14         219            dec a
04AB 12013C     219            lcall ?Set_Cursor_2 ; Select column and row
04AE D0E0       219            pop acc
04B0            220            
04B0 22         221            ret
04B1            222   
04B1            223   Read_ADC:
04B1 C2EF       224            clr ADCF
04B3 D2EE       225            setb ADCS ;  ADC start trigger signal
04B5 30EFFD     226       jnb ADCF, $ ; Wait for conversion complete
04B8            227       
04B8            228       ; Read the ADC result and store in [R1, R0]
04B8 E5C2       229       mov a, ADCRL
04BA 540F       230       anl a, #0x0f
04BC F8         231       mov R0, a
04BD E5C3       232       mov a, ADCRH   
04BF C4         233       swap a
04C0 C0E0       234       push acc
04C2 540F       235       anl a, #0x0f
04C4 F9         236       mov R1, a
04C5 D0E0       237       pop acc
04C7 54F0       238       anl a, #0xf0
04C9 48         239       orl a, R0
04CA F8         240       mov R0, A
04CB 22         241            ret
04CC            242   
04CC            243   
04CC            244   ; this function reads the overall temperature
04CC            245   ; (cold + hot) junction and turns the value in bcd
04CC            246   Read_Temp:
04CC            247            ; Read the signal connected to AIN7
04CC 53E8F0     248            anl ADCCON0, #0xF0
04CF 43E807     249            orl ADCCON0, #0x07 ; Select channel 7
04D2            250   Average_ADC:
04D2 753E00     251            mov x+0, #low (0 % 0x10000) 
04D5 753F00     251            mov x+1, #high(0 % 0x10000) 
04D8 754000     251            mov x+2, #low (0 / 0x10000) 
04DB 754100     251            mov x+3, #high(0 / 0x10000) 
04DE 7D64       252            mov r5, #100
04E0            253   Sum_loop0:
04E0 1204B1     254            lcall Read_ADC
04E3            255       
04E3            256       ; Convert to voltage
04E3 8842       257            mov y+0, R0
04E5 8943       258            mov y+1, R1
04E7 754400     259            mov y+2, #0
04EA 754500     260            mov y+3, #0
04ED            261   
04ED 12023C     262            lcall add32
04F0 DDEE       263            djnz r5, Sum_loop0
04F2            264   
04F2 754264     265            mov y+0, #low (100 % 0x10000) 
04F5 754300     265            mov y+1, #high(100 % 0x10000) 
04F8 754400     265            mov y+2, #low (100 / 0x10000) 
04FB 754500     265            mov y+3, #high(100 / 0x10000) 
04FE 12037E     266            lcall div32
0501            267   
0501 7542C8     268            mov y+0, #low (51400 % 0x10000) 
0504 7543C8     268            mov y+1, #high(51400 % 0x10000) 
0507 754400     268            mov y+2, #low (51400 / 0x10000) 
050A 754500     268            mov y+3, #high(51400 / 0x10000)  ; VCC voltage measured
050D 1202F1     269            lcall mul32
0510 7542FF     270            mov y+0, #low (4095 % 0x10000) 
0513 75430F     270            mov y+1, #high(4095 % 0x10000) 
0516 754400     270            mov y+2, #low (4095 / 0x10000) 
0519 754500     270            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
051C 12037E     271            lcall div32
051F            272   
051F 7542E8     273            mov y+0, #low (1000 % 0x10000) 
0522 754303     273            mov y+1, #high(1000 % 0x10000) 
0525 754400     273            mov y+2, #low (1000 / 0x10000) 
0528 754500     273            mov y+3, #high(1000 / 0x10000) 
052B 1202F1     274            lcall mul32
052E            275   
052E 754264     276            mov y+0, #low (100 % 0x10000) 
0531 754300     276            mov y+1, #high(100 % 0x10000) 
0534 754400     276            mov y+2, #low (100 / 0x10000) 
0537 754500     276            mov y+3, #high(100 / 0x10000) 
053A 1202F1     277            lcall mul32
053D            278   
053D 75421D     279            mov y+0, #low (90909 % 0x10000) 
0540 754363     279            mov y+1, #high(90909 % 0x10000) 
0543 754401     279            mov y+2, #low (90909 / 0x10000) 
0546 754500     279            mov y+3, #high(90909 / 0x10000) 
0549 12037E     280            lcall div32
054C            281   
054C 754229     282            mov y+0, #low (41 % 0x10000) 
054F 754300     282            mov y+1, #high(41 % 0x10000) 
0552 754400     282            mov y+2, #low (41 / 0x10000) 
0555 754500     282            mov y+3, #high(41 / 0x10000) 
0558 12037E     283            lcall div32
055B            284   
055B 754214     285            mov y+0, #low (20 % 0x10000) 
055E 754300     285            mov y+1, #high(20 % 0x10000) 
0561 754400     285            mov y+2, #low (20 / 0x10000) 
0564 754500     285            mov y+3, #high(20 / 0x10000) 
0567 12023C     286            lcall add32
056A            287   
056A 754210     288            mov y+0, #low (10000 % 0x10000) 
056D 754327     288            mov y+1, #high(10000 % 0x10000) 
0570 754400     288            mov y+2, #low (10000 / 0x10000) 
0573 754500     288            mov y+3, #high(10000 / 0x10000) 
0576 1202F1     289            lcall mul32
0579            290   
0579            291            ; Convert to BCD and display
0579 120177     292            lcall hex2bcd
057C C0E0       293            push acc
057E 7405       293            mov a, #5
0580 14         293            dec a
0581 12013C     293            lcall ?Set_Cursor_2 ; Select column and row
0584 D0E0       293            pop acc
0586 C000       294            push ar0
0588 A849       294            mov r0, bcd+3
058A 120143     294            lcall ?Display_BCD
058D D000       294            pop ar0
058F C000       295            push ar0
0591 A848       295            mov r0, bcd+2
0593 120143     295            lcall ?Display_BCD
0596 D000       295            pop ar0
0598 C0E0       296            push acc
059A 742E       296            mov a, #'.'
059C 1200F4     296            lcall ?WriteData
059F D0E0       296            pop acc
05A1 C000       297            push ar0
05A3 A847       297            mov r0, bcd+1
05A5 120143     297            lcall ?Display_BCD
05A8 D000       297            pop ar0
05AA C000       298            push ar0
05AC A846       298            mov r0, bcd+0
05AE 120143     298            lcall ?Display_BCD
05B1 D000       298            pop ar0
05B3            299            
05B3            300            ; Wait 500 ms between conversions
05B3 7A32       301            mov R2, #50
05B5 12060F     302            lcall waitms
05B8            303   
05B8 22         304            ret
05B9            305   
05B9            306   ;------------------------------------;
05B9            307   ; Check for pushbutton press         ;
05B9            308   ;------------------------------------;
05B9            309   LCD_PB:
05B9            310            ; Set variables to 1: 'no push button pressed'
05B9 D200       311            setb PB0
05BB D201       312            setb PB1
05BD D202       313            setb PB2
05BF D203       314            setb PB3
05C1 D204       315            setb PB4
05C3            316            ; The input pin used to check set to '1'
05C3 D295       317            setb P1.5
05C5            318            
05C5            319            ; Check if any push button is pressed
05C5 C280       320            clr P0.0
05C7 C281       321            clr P0.1
05C9 C282       322            clr P0.2
05CB C283       323            clr P0.3
05CD C293       324            clr P1.3
05CF 20953C     325            jb P1.5, LCD_PB_Done
05D2            326   
05D2            327            ; Debounce
05D2 7A32       328            mov R2, #50
05D4 12060F     329            lcall waitms
05D7 209534     330            jb P1.5, LCD_PB_Done
05DA            331   
05DA            332            ; Set the LCD data pins to logic 1
05DA D280       333            setb P0.0
05DC D281       334            setb P0.1
05DE D282       335            setb P0.2
05E0 D283       336            setb P0.3
05E2 D293       337            setb P1.3
05E4            338            
05E4            339            ; Check the push buttons one by one
05E4 C293       340            clr P1.3
05E6 A295       341            mov c, P1.5
05E8 9200       342            mov PB0, c
05EA D293       343            setb P1.3
05EC            344   
05EC C280       345            clr P0.0
05EE A295       346            mov c, P1.5
05F0 9201       347            mov PB1, c
05F2 D280       348            setb P0.0
05F4            349            
05F4 C281       350            clr P0.1
05F6 A295       351            mov c, P1.5
05F8 9202       352            mov PB2, c
05FA D281       353            setb P0.1
05FC            354            
05FC C282       355            clr P0.2
05FE A295       356            mov c, P1.5
0600 9203       357            mov PB3, c
0602 D282       358            setb P0.2
0604            359            
0604 C283       360            clr P0.3
0606 A295       361            mov c, P1.5
0608 9204       362            mov PB4, c
060A D283       363            setb P0.3
060C            364   
060C            365            ; If a button was pressed, set the flag
060C 7B01       366            mov R3, #1
060E            367   
060E            368   LCD_PB_Done:             
060E 22         369            ret
060F            370   
060F            371   ;---------------------------------;
060F            372   ; Wait 'R2' milliseconds          ;
060F            373   ;---------------------------------;
060F            374   waitms:
060F C000       375       push AR0
0611 C001       376       push AR1
0613 7928       377   L6: mov R1, #40
0615 7868       378   L5: mov R0, #104
0617 D8FE       379   L4: djnz R0, L4 ; 4 cycles->4*60.24ns*104=25.0us
0619 D9FA       380       djnz R1, L5 ; 25us*40=1.0ms
061B DAF6       381       djnz R2, L6 ; number of millisecons to wait passed in R2
061D D001       382       pop AR1
061F D000       383       pop AR0
0621 22         384       ret
0622            385   
0622            386   
0622            387   ; Main program code begins here!
0622            388   initialize:
0622            389   
0622            390            ;;;;;;;;;;;;;;;;;;;
0622            391            ;; CONFIGURATION ;;
0622            392            ;;;;;;;;;;;;;;;;;;;
0622            393   
0622            394            ; Configure all the pins for biderectional I/O
0622 75AC00     395            mov     P3M1, #0x00
0625 75AD00     396            mov     P3M2, #0x00
0628 75B300     397            mov     P1M1, #0x00
062B 75B400     398            mov     P1M2, #0x00
062E 75B100     399            mov     P0M1, #0x00
0631 75B200     400            mov     P0M2, #0x00
0634            401   
0634            402            ; The following code initializes the serial port
0634 438E10     403            orl     CKCON, #0x10 ; CLK is the input for timer 1
0637 438780     404            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
063A 759852     405            mov     SCON, #0x52
063D 53C4DF     406            anl     T3CON, #0b11011111
0640 53890F     407            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0643 438920     408            orl     TMOD, #0x20 ; Timer 1 Mode 2
0646 758DF7     409            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0649 D28E       410            setb TR1
064B            411   
064B            412            ; Initialize the pin used by the ADC (P1.1) as input.
064B 43B302     413            orl     P1M1, #0b00000010
064E 53B4FD     414            anl     P1M2, #0b11111101
0651            415            
0651            416            ; Initialize and start the ADC:
0651 53E8F0     417            anl ADCCON0, #0xF0
0654 43E807     418            orl ADCCON0, #0x07 ; Select channel 7
0657            419            ; AINDIDS select if some pins are analog inputs or digital I/O:
0657 75F600     420            mov AINDIDS, #0x00 ; Disable all analog inputs
065A 43F680     421            orl AINDIDS, #0b10000000 ; P1.1 is analog input
065D 43E101     422            orl ADCCON1, #0x01 ; Enable ADC
0660            423            
0660            424            ; Initialize the Timers
0660 1203E7     425       lcall Timer0_Init ; Timer 1 (used to play noise from the speaker)
0663 12040A     426       lcall Timer2_Init ; Timer 2 (used to trigger an ISR every 1 second)
0666            427   
0666            428            ; Initialize the LCD - Toggle the 'E' pin
0666 1200FE     429       lcall LCD_4BIT ; Initialize the LCD display in 4 bit mode
0669            430            ;cpl TR0 ; toggle timer 0 immediately, or else it will make noise right away!
0669            431   
0669            432            ; Display the initial strings
0669 C0E0       433            push acc
066B 7401       433            mov a, #1
066D 14         433            dec a
066E 12013E     433            lcall ?Set_Cursor_1 ; Select column and row
0671 D0E0       433            pop acc
0673 C083       434            push dph
0675 C082       434            push dpl
0677 C0E0       434            push acc
0679 90002E     434            mov dptr, #initial_msg1
067C 120131     434            lcall ?Send_Constant_String
067F D0E0       434            pop acc
0681 D082       434            pop dpl
0683 D083       434            pop dph
0685            435   
0685 C0E0       436            push acc
0687 7401       436            mov a, #1
0689 14         436            dec a
068A 12013C     436            lcall ?Set_Cursor_2 ; Select column and row
068D D0E0       436            pop acc
068F C083       437            push dph
0691 C082       437            push dpl
0693 C0E0       437            push acc
0695 90003F     437            mov dptr, #initial_mgs2
0698 120131     437            lcall ?Send_Constant_String
069B D0E0       437            pop acc
069D D082       437            pop dpl
069F D083       437            pop dph
06A1            438            
06A1            439            ; Set the following variables to zero on startup
06A1 7400       440            mov a, #0x0
06A3 D4         441            da a
06A4 F53B       442            mov current_state, a
06A6 F505       443            mov display_time, a
06A8 7430       444            mov a, #0x30
06AA D4         445            da a
06AB F532       446            mov soak_temp, a
06AD 7460       447            mov a, #0x60
06AF D4         448            da a
06B0 F534       449            mov soak_time, a
06B2 7400       450            mov a, #0x00
06B4 D4         451            da a
06B5 F536       452            mov reflow_temp, a
06B7 7445       453            mov a, #0x45
06B9 D4         454            da a
06BA F538       455            mov reflow_time, a
06BC            456   
06BC            457   
06BC            458   ;;;;;;;;;;;;;;;;;;;;;;;;
06BC            459   ; FINITE STATE MACHINE ;
06BC            460   ;;;;;;;;;;;;;;;;;;;;;;;;
06BC            461   
06BC            462   ; Start of the finite state machine
06BC            463   FSM1: 
06BC E53B       464            mov a, current_state 
06BE            465   
06BE            466   
06BE            467   ; STATE 0 - Off State (power 0%)
06BE            468   off_state:
06BE D2CA       469            setb TR2 ; Start Timer 2
06C0            470   
06C0 753D00     471            mov pwm, #0 ; set the oven power to 0 in this state
06C3            472            
06C3 C207       473            clr cooling_done
06C5 D206       474            setb next_state ; play sound out of the speaker 
06C7            475   
06C7            476            ; set the initial values on the screen
06C7 C0E0       477            push acc
06C9 7403       477            mov a, #3
06CB 14         477            dec a
06CC 12013C     477            lcall ?Set_Cursor_2 ; Select column and row
06CF D0E0       477            pop acc ; display the initial soak temperature
06D1 C000       478            push ar0
06D3 A832       478            mov r0, soak_temp
06D5 120143     478            lcall ?Display_BCD
06D8 D000       478            pop ar0
06DA            479   
06DA C0E0       480            push acc
06DC 7407       480            mov a, #7
06DE 14         480            dec a
06DF 12013C     480            lcall ?Set_Cursor_2 ; Select column and row
06E2 D0E0       480            pop acc ; display the initial soak time
06E4 C000       481            push ar0
06E6 A834       481            mov r0, soak_time
06E8 120143     481            lcall ?Display_BCD
06EB D000       481            pop ar0
06ED            482   
06ED C0E0       483            push acc
06EF 740B       483            mov a, #11
06F1 14         483            dec a
06F2 12013C     483            lcall ?Set_Cursor_2 ; Select column and row
06F5 D0E0       483            pop acc
06F7            483    ; display the initial reflow temperature
06F7 C000       484            push ar0
06F9 A836       484            mov r0, reflow_temp
06FB 120143     484            lcall ?Display_BCD
06FE D000       484            pop ar0
0700            485   
0700 C0E0       486            push acc
0702 740E       486            mov a, #14
0704 14         486            dec a
0705 12013C     486            lcall ?Set_Cursor_2 ; Select column and row
0708 D0E0       486            pop acc ; display the initial reflow time
070A C000       487            push ar0
070C A838       487            mov r0, reflow_time
070E 120143     487            lcall ?Display_BCD
0711 D000       487            pop ar0
0713            488   
0713            489            ; we first want the user to set the soak temperature
0713            490            soak_temp_button:
0713 1205B9     491            lcall LCD_PB ; check for pushbutton presses
0716 7A32       492            mov r2, #50
0718 12060F     493            lcall waitms
071B 1205B9     494            lcall LCD_PB 
071E            495            
071E 300008     496            jnb PB0, inc_soak_temp ; if the increment button is pressed
0721 30010E     497            jnb PB1, dec_soak_temp ; if the decrement button is pressed
0724 300227     498            jnb PB2, soak_time_button ; if the next button is pressed
0727 8010       499            sjmp display_soak_temp ; check button presses again
0729            500   
0729            501            inc_soak_temp:
0729 E532       502            mov a, soak_temp
072B 2401       503            add a, #0x01
072D D4         504            da a
072E F532       505            mov soak_temp, a
0730 8007       506            sjmp display_soak_temp
0732            507   
0732            508            dec_soak_temp:
0732 E532       509            mov a, soak_temp
0734 2499       510            add a, #0x99
0736 D4         511            da a
0737 F532       512            mov soak_temp, a
0739            513   
0739            514            display_soak_temp:
0739 C0E0       515            push acc
073B 7403       515            mov a, #3
073D 14         515            dec a
073E 12013C     515            lcall ?Set_Cursor_2 ; Select column and row
0741 D0E0       515            pop acc ; display the current soak temperature
0743 C000       516            push ar0
0745 A832       516            mov r0, soak_temp
0747 120143     516            lcall ?Display_BCD
074A D000       516            pop ar0
074C 80C5       517            sjmp soak_temp_button
074E            518   
074E            519            ; next we want to user the set the soak time (in seconds)
074E            520            soak_time_button:
074E 1205B9     521            lcall LCD_PB ; check for pushbutton presses
0751 7A32       522            mov r2, #50
0753 12060F     523            lcall waitms
0756 1205B9     524            lcall LCD_PB
0759            525            
0759 300008     526            jnb PB0, inc_soak_time ; if the increment button is pressed
075C 30010E     527            jnb PB1, dec_soak_time ; if the decrement button is pressed
075F 300227     528            jnb PB2, reflow_temp_button ; if the next button is pressed
0762 8010       529            sjmp display_soak_time ; check button presses again
0764            530   
0764            531            inc_soak_time:
0764 E534       532            mov a, soak_time
0766 2401       533            add a, #0x01
0768 D4         534            da a
0769 F534       535            mov soak_time, a
076B 8007       536            sjmp display_soak_time
076D            537   
076D            538            dec_soak_time:
076D E534       539            mov a, soak_time
076F 2499       540            add a, #0x99
0771 D4         541            da a
0772 F534       542            mov soak_time, a
0774            543            
0774            544            display_soak_time:
0774 C0E0       545            push acc
0776 7407       545            mov a, #7
0778 14         545            dec a
0779 12013C     545            lcall ?Set_Cursor_2 ; Select column and row
077C D0E0       545            pop acc ; display the current soak time
077E C000       546            push ar0
0780 A834       546            mov r0, soak_time
0782 120143     546            lcall ?Display_BCD
0785 D000       546            pop ar0
0787 80C5       547            sjmp soak_time_button
0789            548   
0789            549            ; third, we want the user to set the reflow temperature 
0789            550            reflow_temp_button:
0789 1205B9     551            lcall LCD_PB ; check for pushbutton presses
078C 7A32       552            mov r2, #50
078E 12060F     553            lcall waitms
0791 1205B9     554            lcall LCD_PB
0794            555            
0794 300008     556            jnb PB0, inc_reflow_temp ; if the increment button is pressed
0797 30010E     557            jnb PB1, dec_reflow_temp ; if the decrement button is pressed
079A 300227     558            jnb PB2, reflow_time_button ; if the next button is pressed
079D 80EA       559            sjmp reflow_temp_button ; check button presses again
079F            560   
079F            561            inc_reflow_temp:
079F E536       562            mov a, reflow_temp
07A1 2401       563            add a, #0x01
07A3 D4         564            da a
07A4 F536       565            mov reflow_temp, a
07A6 8007       566            sjmp display_reflow_temp
07A8            567   
07A8            568            dec_reflow_temp:
07A8 E536       569            mov a, reflow_temp
07AA 2499       570            add a, #0x99
07AC D4         571            da a
07AD F536       572            mov reflow_temp, a
07AF            573   
07AF            574            display_reflow_temp:
07AF C0E0       575            push acc
07B1 740B       575            mov a, #11
07B3 14         575            dec a
07B4 12013C     575            lcall ?Set_Cursor_2 ; Select column and row
07B7 D0E0       575            pop acc ; display the current reflow temperature
07B9 C000       576            push ar0
07BB A836       576            mov r0, reflow_temp
07BD 120143     576            lcall ?Display_BCD
07C0 D000       576            pop ar0
07C2 80C5       577            sjmp reflow_temp_button
07C4            578   
07C4            579            ; finally, we want the user to set the reflow time 
07C4            580            reflow_time_button:
07C4 1205B9     581            lcall LCD_PB ; check for pushbutton presses
07C7 7A32       582            mov r2, #50
07C9 12060F     583            lcall waitms
07CC 1205B9     584            lcall LCD_PB
07CF            585            
07CF 300008     586            jnb PB0, inc_reflow_time ; if the increment button is pressed
07D2 30010E     587            jnb PB1, dec_reflow_time ; if the decrement button is pressed
07D5 300227     588            jnb PB2, wait_for_start ; if the next button is pressed
07D8 80EA       589            sjmp reflow_time_button ; check button presses again
07DA            590   
07DA            591            inc_reflow_time:
07DA E538       592            mov a, reflow_time
07DC 2401       593            add a, #0x01
07DE D4         594            da a
07DF F538       595            mov reflow_time, a
07E1 8007       596            sjmp display_reflow_time
07E3            597   
07E3            598            dec_reflow_time:
07E3 E538       599            mov a, reflow_time
07E5 2499       600            add a, #0x99
07E7 D4         601            da a
07E8 F538       602            mov reflow_time, a 
07EA            603   
07EA            604            display_reflow_time:
07EA C0E0       605            push acc
07EC 740E       605            mov a, #14
07EE 14         605            dec a
07EF 12013C     605            lcall ?Set_Cursor_2 ; Select column and row
07F2 D0E0       605            pop acc ; display the current reflow time
07F4 C000       606            push ar0
07F6 A838       606            mov r0, reflow_time
07F8 120143     606            lcall ?Display_BCD
07FB D000       606            pop ar0
07FD 80C5       607            sjmp reflow_time_button 
07FF            608   
07FF            609            ; if we reach this label, all paramters have been set
07FF            610            ; we are now waiting for the user to press the start/stop button (PB4) to begin
07FF            611            wait_for_start:
07FF 1205B9     612            lcall LCD_PB ; check for pushbuttons presses
0802 2004FA     613            jb PB4, wait_for_start ; infinite loop if the start button is not pressed
0805 753B01     614            mov current_state, #1 ; if the start button is pressed, move to state 1 (preheat)
0808            615   
0808            616   
0808            617   ; STATE 1 - Preheat State (increase temperature to soak_temp - power 100%), check for it to reach over 50 C within 60 seconds
0808            618   preheat_state:
0808            619   
0808 E53B       620            mov a, current_state
080A B40154     621            cjne a, #1, soak_state ; if current state is not 1, move to state 2
080D 753D64     622            mov pwm, #100 ; set the oven power to 100% in this state
0810            623   
0810            624            ; reset the state_time
0810 E4         625            clr a
0811 F53A       626            mov state_time, a
0813 D206       627            setb next_state
0815 D205       628            setb display_time
0817            629   
0817            630            ; display the working message string
0817 C0E0       631            push acc
0819 7401       631            mov a, #1
081B 14         631            dec a
081C 12013C     631            lcall ?Set_Cursor_2 ; Select column and row
081F D0E0       631            pop acc
0821 C083       632            push dph
0823 C082       632            push dpl
0825 C0E0       632            push acc
0827 900050     632            mov dptr, #preheat_mgs
082A 120131     632            lcall ?Send_Constant_String
082D D0E0       632            pop acc
082F D082       632            pop dpl
0831 D083       632            pop dph
0833            633   
0833            634            check_soak_temp: 
0833            635            ; fetch the current temperature
0833 1204CC     636            lcall Read_Temp
0836            637            ; moving the bcd value into current_temp
0836 854039     638            mov current_temp, x+2
0839            639   
0839            640            ; check if the current temperature is equal to the user set soak temperature
0839 E539       641            mov a, current_temp
083B 9532       642            subb a, soak_temp
083D 4002       643            jc check_for_error ; if have not yet hit the soak temperature, check for error
083F 501D       644            jnc preheat_state_done ; if the current temperature is equal or greater to the soak_temp, the preheat state is done
0841            645            
0841            646            ; check if the current temperature is less than 50 degrees
0841            647            check_for_error:
0841 E539       648            mov a, current_temp
0843 9432       649            subb a, #50
0845 4002       650            jc error ; if temperature is less than 50 degrees, check how much time has passed
0847 5009       651            jnc soak_not_reached ; if temperature is greater than or equal to 50 degrees, we are safe 
0849            652   
0849            653            ; if the current temperature is less than 50 degrees, check the state time
0849            654            error: 
0849 E53A       655            mov a, state_time
084B 943C       656            subb a, #60
084D 4003       657            jc soak_not_reached ; if less than 60 seconds have passed, we have not reached the termination condition
084F 0206BE     658            ljmp off_state ; if at least 60 seconds have passed, we must terminate the program 
0852            659   
0852            660            ; if we are not ready to procede to soak, check the stop button
0852            661            soak_not_reached:
0852 1205B9     662            lcall LCD_PB ; check for pushbutton presses
0855 2004DB     663            jb PB4, check_soak_temp 
0858 753B00     664            mov current_state, #0 ; if the stop button is pressed, return to state 0
085B 0206BE     665            ljmp off_state
085E            666   
085E            667            preheat_state_done: 
085E 753B02     668            mov current_state, #2
0861            669   
0861            670   
0861            671   ; STATE 2 - Soak State (maintain temperature - power 20%)
0861            672   soak_state: 
0861            673   
0861 E53B       674            mov a, current_state
0863 B4023B     675            cjne a, #2, ramp_state ; if current state is not 0, move to state 1
0866 753D14     676            mov pwm, #20 ; set the oven power to 20% in this state
0869            677   
0869            678            ; reset the state_time
0869 E4         679            clr a
086A F53A       680            mov state_time, a
086C D206       681            setb next_state
086E            682   
086E            683            ; display the working message string
086E C0E0       684            push acc
0870 7401       684            mov a, #1
0872 14         684            dec a
0873 12013C     684            lcall ?Set_Cursor_2 ; Select column and row
0876 D0E0       684            pop acc
0878            684   
0878 C083       685            push dph
087A C082       685            push dpl
087C C0E0       685            push acc
087E 900061     685            mov dptr, #soak_mgs
0881 120131     685            lcall ?Send_Constant_String
0884 D0E0       685            pop acc
0886 D082       685            pop dpl
0888 D083       685            pop dph
088A            686            
088A            687            ; check if the state_time is equal to the user set soak_time
088A            688            check_soak_time:
088A E53A       689            mov a, state_time
088C 9534       690            subb a, soak_time
088E 4002       691            jc  ramp_not_reached ; if have not yet hit then soak_time, check if the stop button has been pressed
0890 500C       692            jnc soak_state_done ; if the state_time is equal or greater to the soak_time, proceed to the ramp state
0892            693   
0892            694            ; if we are not ready to procede to ramp to reflow, check the stop button
0892            695            ramp_not_reached:
0892 1205B9     696            lcall LCD_PB ; check for pushbutton presses
0895 2004F2     697            jb PB4, check_soak_time 
0898 753B00     698            mov current_state, #0 ; if the stop button is pressed, return to state 0
089B 0206BE     699            ljmp off_state 
089E            700   
089E            701            soak_state_done:
089E 753B03     702            mov current_state, #3
08A1            703   
08A1            704   
08A1            705   ; STATE 3 - Ramp to Reflow State (increase temperature to reflow_temp - power 100%)      
08A1            706   ramp_state:
08A1            707   
08A1 E53B       708            mov a, current_state
08A3 B40341     709            cjne a, #3, reflow_state ; if current state is not 3, move to state 4
08A6 753D64     710            mov pwm, #100 ; set the oven power to 100% in this state
08A9            711            
08A9            712            ; reset the state_time
08A9 E4         713            clr a
08AA F53A       714            mov state_time, a
08AC D206       715            setb next_state
08AE            716   
08AE            717            ; display the working message string
08AE C0E0       718            push acc
08B0 7401       718            mov a, #1
08B2 14         718            dec a
08B3 12013C     718            lcall ?Set_Cursor_2 ; Select column and row
08B6 D0E0       718            pop acc
08B8 C083       719            push dph
08BA C082       719            push dpl
08BC C0E0       719            push acc
08BE 900072     719            mov dptr, #ramp_mgs
08C1 120131     719            lcall ?Send_Constant_String
08C4 D0E0       719            pop acc
08C6 D082       719            pop dpl
08C8 D083       719            pop dph
08CA            720   
08CA            721   
08CA            722            check_ramp_temp: 
08CA            723            ; fetch the current temperature 
08CA 1204CC     724            lcall Read_Temp
08CD            725            ; moving the bcd value into current_temp
08CD 854039     726            mov current_temp, x+2
08D0            727   
08D0            728            ; check if the current temperature is equal to the user set soak temperature
08D0 E539       729            mov a, current_temp
08D2 9536       730            subb a, reflow_temp
08D4 4002       731            jc reflow_not_reached ; if have not yet hit the reflow temperature, check if the stop button is pressed
08D6 500C       732            jnc ramp_state_done  ; if the current temperature is equal or greater to the reflow_temp, the ramp state is done
08D8            733   
08D8            734            ; if we are not ready to procede to reflow, check the stop button
08D8            735            reflow_not_reached:
08D8 1205B9     736            lcall LCD_PB ; check for pushbutton presses
08DB 2004EC     737            jb PB4, check_ramp_temp 
08DE 753B00     738            mov current_state, #0 ; if the stop button is pressed, return to state 0
08E1 0206BE     739            ljmp off_state
08E4            740   
08E4            741            ramp_state_done: 
08E4 753B04     742            mov current_state, #4
08E7            743   
08E7            744   
08E7            745   
08E7            746   ; STATE 4 - Reflow State (maintain temperature - power 20%)
08E7            747   reflow_state:
08E7            748   
08E7 E53B       749            mov a, current_state
08E9 B4043B     750            cjne a, #4, cooling ; if current state is not 4, move to state 5
08EC 753D14     751            mov pwm, #20 ; set the oven power to 20% in this state
08EF            752   
08EF            753            ; reset the state_time
08EF E4         754            clr a
08F0 F53A       755            mov state_time, a
08F2 D206       756            setb next_state
08F4            757   
08F4            758            ; display the working message string
08F4 C0E0       759            push acc
08F6 7401       759            mov a, #1
08F8 14         759            dec a
08F9 12013C     759            lcall ?Set_Cursor_2 ; Select column and row
08FC D0E0       759            pop acc
08FE C083       760            push dph
0900 C082       760            push dpl
0902 C0E0       760            push acc
0904 900083     760            mov dptr, #reflow_mgs
0907 120131     760            lcall ?Send_Constant_String
090A D0E0       760            pop acc
090C D082       760            pop dpl
090E D083       760            pop dph
0910            761   
0910            762            ; check if the state_time is equal to the user set reflow_time
0910            763            check_reflow_time:
0910 E53A       764            mov a, state_time
0912 9538       765            subb a, reflow_time
0914 4002       766            jc  cooling_not_reached ; if we have not yet hit the reflow_time, check if the stop button has been pressed
0916 500C       767            jnc reflow_state_done ; if the state_time is equal or greater to the reflow_time, proceed to the cooling state
0918            768   
0918            769            ; if we are not ready to procede to ramp to reflow, check the stop button
0918            770            cooling_not_reached:
0918 1205B9     771            lcall LCD_PB ; check for pushbutton presses
091B 2004F2     772            jb PB4, check_reflow_time 
091E 753B00     773            mov current_state, #0 ; if the stop button is pressed, return to state 0
0921 0206BE     774            ljmp off_state 
0924            775   
0924            776            reflow_state_done:
0924 753B05     777            mov current_state, #5
0927            778   
0927            779   
0927            780   ; STATE 5 - Cooling (power fully off)
0927            781   cooling:
0927            782   
0927 753D00     783            mov pwm, #0 ; set the oven power to 0% in this state
092A            784   
092A            785            ; display the working message string
092A C0E0       786            push acc
092C 7401       786            mov a, #1
092E 14         786            dec a
092F 12013C     786            lcall ?Set_Cursor_2 ; Select column and row
0932 D0E0       786            pop acc
0934 C083       787            push dph
0936 C082       787            push dpl
0938 C0E0       787            push acc
093A 900094     787            mov dptr, #cooling_mgs
093D 120131     787            lcall ?Send_Constant_String
0940 D0E0       787            pop acc
0942 D082       787            pop dpl
0944 D083       787            pop dph
0946            788   
0946            789            ; reset the state_time
0946 E4         790            clr a
0947 F53A       791            mov state_time, a
0949 D206       792            setb next_state
094B            793   
094B            794            check_cooling_temp: 
094B            795            ; fetch the current temperature 
094B 1204CC     796            lcall Read_Temp
094E            797            ; moving the bcd value into current_temp
094E 854839     798            mov current_temp, bcd+2
0951            799   
0951            800            ; check if the current temperature is equal to the user set soak temperature
0951 E539       801            mov a, current_temp
0953 943C       802            subb a, #60
0955 4002       803            jc cooling_state_done ; if the current temperature is less than 60 degrees, we have finished the cooling stage
0957 50F2       804            jnc check_cooling_temp  ; if the current temperature is greater than or equal to 60 degrees, check the temperature again
0959            805   
0959            806            cooling_state_done:
0959 753B00     807            mov current_state, #0
095C C205       808            clr display_time
095E 753A00     809            mov state_time, #0
0961            810   
0961            811            loop:
0961 E53A       812            mov a, state_time
0963 9406       813            subb a, #6 ; wait 6 seconds - 2 second period for each speaker play
0965 40FA       814            jc loop ; condition not yet met
0967 0206BE     815            ljmp off_state ; FSM done 
096A            816   
096A            817            
096A            818   
096A            819   
