0000              1   ; Implementation of the finite state machine to control the stages of the reflow oven
0000              2   
                  4   $LIST
0000              6   
0000              7   ;  N76E003 pinout:
0000              8   ;                               -------
0000              9   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             10   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             11   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             12   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             13   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             14   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             15   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             16   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             17   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             18   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             19   ;                               -------
0000             20   ;
0000             21   
0000             22   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD          EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER0_RATE   EQU 2048     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             25   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             27   TIMER2_RATE   EQU 100      ; 100Hz or 10ms
0000             28   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 2 input divide to 16 in T2MOD
0000             29   
0000             30   ; Relevant vectors
0000             31   ; Reset vector
0000             32   org 0x0000
0000 0205F0      33       ljmp initialize
0003             34   
0003             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 0203FD      37            ljmp Timer0_ISR
000E             38   
000E             39   ; Timer/Counter 2 overflow interrupt vector
002B             40   org 0x002B
002B 020427      41            ljmp Timer2_ISR
002E             42            
002E             43            
002E             44   ;;;;;;;;;;;;
002E             45   ;   PINS   ;
002E             46   ;;;;;;;;;;;;
002E             47      
002E             48   LCD_RS     equ P1.3
002E             49   ;LCD_RW    equ PX.X  ; Not used in this code, connect the pin to GND
002E             50   LCD_E      equ P1.4
002E             51   LCD_D4     equ P0.0
002E             52   LCD_D5     equ P0.1
002E             53   LCD_D6     equ P0.2
002E             54   LCD_D7     equ P0.3   
002E             55   PWM_OUT    equ P1.0 ; Toggles power to the oven (Logic 1=oven on)
002E             56   SOUND_OUT  equ P0.4 ; Speaker connection 
002E             57   
002E             58   ; Decleration of one byte current state variable and parameters
0030             59   DSEG at 0x30
0030             60   Count1ms:      ds 2 ; Used to determine when a second has passed
0032             61   soak_temp:     ds 2 ; User set variable for the desired soak temperature
0034             62   soak_time:     ds 2 ; User set variable for the length of the soak time
0036             63   reflow_temp:   ds 2 ; User set variable for the reflow temperature
0038             64   reflow_time:   ds 1 ; User set variable for timein the reflow state
0039             65   current_temp:  ds 1 ; Current temperature in the oven
003A             66   state_time:    ds 1 ; Current amount of time we have been in a given state
003B             67   current_state: ds 1 ; Current state of the finite state machine
003C             68   pwm_counter:   ds 1 ; Free running counter 0, 1, 2, ..., 100, 0 used for PWM purposes
003D             69   pwm:           ds 1 ; pwm percentage variable - adjust as needed in each state
003E             70   
003E             71   ;for math_32.inc library
003E             72   x:   ds 4
0042             73   y:   ds 4
0046             74   bcd: ds 5
004B             75   
004B             76   ; decleration of one bit variables (flags)
0000             77   BSEG
0000             78   ; These one bit variables store the value of the pushbuttons after calling 'LCD_PB' 
0000             79   PB0:                dbit 1 ; incremement (INC)
0001             80   PB1:                dbit 1 ; decremement (DEC)
0002             81   PB2:                dbit 1 ; next parameter (NXT)
0003             82   PB3:                dbit 1 ; currently unused (PB3)
0004             83   PB4:                dbit 1 ; start / emergency stop (EMR)
0005             84   display_time:  dbit 1 ; if this flag is set, we want to start displaying the state time
0006             85   next_state:    dbit 1 ; if this flag is set, we want to make a speaker beep
0007             86   cooling_done:  dbit 1 ; flag set if cooling state is finished
0008             87   mf:            dbit 1 ; used for math functions  
0009             88   
002E             89   CSEG
002E             90   
002E             91   ; Strings
002E             92   ;                '1234567890123456'
002E 546F3D20    93   initial_msg1: DB 'To=   C  Tj=20C ',0
     20204320
     20546A3D
     32304320
     00
003F 73312020    94   initial_mgs2: DB 's1  ,   r2  ,   ',0
     2C202020
     72322020
     2C202020
     00
0050             95   ;         s=soak temp, soak time   r=reflow temp,reflow time
0050             96   
0050             97   ;state name messages
0050             98   ;                '1234567890123456'
0050 743D2020    99   preheat_mgs: DB    't=       Preheat',0
     20202020
     20507265
     68656174
     00
0061 743D2020   100   soak_mgs:    DB    't=       Soaking',0
     20202020
     20536F61
     6B696E67
     00
0072 743D2020   101   ramp_mgs:    DB    't=          Ramp',0
     20202020
     20202020
     52616D70
     00
0083 743D2020   102   reflow_mgs:  DB    't=        Reflow',0
     20202020
     20205265
     666C6F77
     00
0094 743D2020   103   cooling_mgs: DB    't=       Cooling',0
     20202020
     20436F6F
     6C696E67
     00
00A5            104   
00A5            105   
00A5            106   ; A library of LCD related functions and utility macros
                108   $LIST
0159            110   
0159            111   ; A library of math related functions and utility macros
                579   $LIST
                113   $LIST
03E7            115   
03E7            116   ; Initialization of timers
03E7            117   ;---------------------------------;
03E7            118   ; Routine to initialize the ISR   ;
03E7            119   ; for timer 0                     ;
03E7            120   ;---------------------------------;
03E7            121   Timer0_Init:
03E7 438E08     122            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03EA E589       123            mov a, TMOD
03EC 54F0       124            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03EE 4401       125            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03F0 F589       126            mov TMOD, a
03F2 758CE0     127            mov TH0, #high(TIMER0_RELOAD)
03F5 758A57     128            mov TL0, #low(TIMER0_RELOAD)
03F8            129            ; Enable the timer and interrupts
03F8 D2A9       130       setb ET0  ; Enable timer 0 interrupt
03FA D28C       131       setb TR0  ; Start timer 0
03FC 22         132            ret
03FD            133   
03FD            134   ;---------------------------------;
03FD            135   ; ISR for timer 0.  Set to execute;
03FD            136   ; every 1/2048Hz to generate a    ;
03FD            137   ; 2048 Hz wave at pin SOUND_OUT   ;
03FD            138   ;---------------------------------;
03FD            139   Timer0_ISR:
03FD            140            ;clr TF0  ; According to the data sheet this is done for us already.
03FD            141            ; Timer 0 doesn't have 16-bit auto-reload, so
03FD C28C       142            clr TR0
03FF 758CE0     143            mov TH0, #high(TIMER0_RELOAD)
0402 758A57     144            mov TL0, #low(TIMER0_RELOAD)
0405 D28C       145            setb TR0
0407 B284       146            cpl SOUND_OUT ; Toggles the speaker pin at 1000 Hz to play noise
0409 32         147            reti
040A            148   
040A            149   ;---------------------------------;
040A            150   ; Routine to initialize the ISR   ;
040A            151   ; for timer 2                     ;
040A            152   ;---------------------------------;
040A            153   Timer2_Init:
040A            154            ; Initialize timer 2 for periodic interrupts
040A 75C800     155            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
040D 75CDD7     156            mov TH2, #high(TIMER2_RELOAD)
0410 75CC79     157            mov TL2, #low(TIMER2_RELOAD)
0413            158            ; Set the reload value
0413 75C9A0     159            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0416 75CBD7     160            mov RCMP2H, #high(TIMER2_RELOAD)
0419 75CA79     161            mov RCMP2L, #low(TIMER2_RELOAD)
041C            162            ; Init the free running 10 ms counter to zero
041C 753C00     163            mov pwm_counter, #0
041F            164            ; Enable the timer and interrupts
041F 439B80     165            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0422 D2CA       166       setb TR2  ; Enable timer 2
0424 D2AF       167            setb EA ; Enable global interrupts
0426            168   
0426 22         169            ret 
0427            170   
0427            171   ;---------------------------------;
0427            172   ; ISR for timer 2                 ;
0427            173   ;---------------------------------;
0427            174   Timer2_ISR:
0427 C2CF       175            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0429 C0D0       176            push psw
042B C0E0       177            push acc
042D            178            
042D 053C       179            inc pwm_counter
042F C3         180            clr c
0430 E53D       181            mov a, pwm
0432 953C       182            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0434 B3         183            cpl c
0435 9290       184            mov PWM_OUT, c
0437            185            
0437 E53C       186            mov a, pwm_counter
0439 B46433     187            cjne a, #100, Timer2_ISR_done ; check if 1000 ms have passed
043C 753C00     188            mov pwm_counter, #0
043F 053A       189            inc state_time ; It is super easy to keep a seconds count here
0441            190   
0441 300518     191            jnb display_time, new_state_noise ; if we are in at least the pre-heat state, begin showing state time on the LCD       Set_Cursor(2,3)
0444 E53A       192            mov a, state_time
0446 D4         193            da a 
0447 F53A       194            mov state_time, a 
0449 C0E0       195            push acc
044B 7403       195            mov a, #3
044D 14         195            dec a
044E 12013C     195            lcall ?Set_Cursor_2 ; Select column and row
0451 D0E0       195            pop acc
0453            195   
0453 C000       196            push ar0
0455 A83A       196            mov r0, state_time
0457 120143     196            lcall ?Display_BCD
045A D000       196            pop ar0
045C            197   
045C            198            new_state_noise:
045C 300607     199            jnb next_state, send_serial ; if we are not entering a new state, jump to the send serial port code
045F B28C       200            cpl TR0 ; Enable/disable timer/counter 0. This line enables the beep sound from the speaker when we enter a new state
0461 200702     201            jb cooling_done, send_serial ; if cooling is done, we play the sound 3 times
0464 C206       202            clr next_state
0466            203   
0466            204            send_serial:
0466 C000       205            push ar0
0468 A83E       205            mov r0, x
046A 120161     205            lcall ?Send_BCD
046D D000       205            pop ar0 ; Assuming the current temperature is stored in a byte of x
046F            206   
046F            207   Timer2_ISR_done:
046F D0E0       208            pop acc
0471 D0D0       209            pop psw
0473 32         210            reti
0474            211   
0474            212   ; Function declearations begins here:
0474            213   ; We can display a number any way we want.  In this case with four decimal places.
0474            214   Display_formated_BCD:
0474 C0E0       215            push acc
0476 7405       215            mov a, #5
0478 14         215            dec a
0479 12013C     215            lcall ?Set_Cursor_2 ; Select column and row
047C D0E0       215            pop acc
047E C000       216            push ar0
0480 A84A       216            mov r0, bcd+4
0482 120143     216            lcall ?Display_BCD
0485 D000       216            pop ar0
0487 C000       217            push ar0
0489 A849       217            mov r0, bcd+3
048B 120143     217            lcall ?Display_BCD
048E D000       217            pop ar0
0490 C000       218            push ar0
0492 A848       218            mov r0, bcd+2
0494 120143     218            lcall ?Display_BCD
0497 D000       218            pop ar0
0499            219            ;Display_char(#'.')
0499 C000       220            push ar0
049B A847       220            mov r0, bcd+1
049D 120143     220            lcall ?Display_BCD
04A0 D000       220            pop ar0
04A2 C000       221            push ar0
04A4 A846       221            mov r0, bcd+0
04A6 120143     221            lcall ?Display_BCD
04A9 D000       221            pop ar0
04AB C0E0       222            push acc
04AD 7406       222            mov a, #6
04AF 14         222            dec a
04B0 12013C     222            lcall ?Set_Cursor_2 ; Select column and row
04B3 D0E0       222            pop acc
04B5            223            
04B5 22         224            ret
04B6            225   
04B6            226   Read_ADC:
04B6 C2EF       227            clr ADCF
04B8 D2EE       228            setb ADCS ;  ADC start trigger signal
04BA 30EFFD     229       jnb ADCF, $ ; Wait for conversion complete
04BD            230       
04BD            231       ; Read the ADC result and store in [R1, R0]
04BD E5C2       232       mov a, ADCRL
04BF 540F       233       anl a, #0x0f
04C1 F8         234       mov R0, a
04C2 E5C3       235       mov a, ADCRH   
04C4 C4         236       swap a
04C5 C0E0       237       push acc
04C7 540F       238       anl a, #0x0f
04C9 F9         239       mov R1, a
04CA D0E0       240       pop acc
04CC 54F0       241       anl a, #0xf0
04CE 48         242       orl a, R0
04CF F8         243       mov R0, A
04D0 22         244            ret
04D1            245   
04D1            246   
04D1            247   ; this function reads the overall temperature
04D1            248   ; (cold + hot) junction and turns the value in bcd
04D1            249   Read_Temp:
04D1            250            ; Read the signal connected to AIN7
04D1 53E8F0     251            anl ADCCON0, #0xF0
04D4 43E807     252            orl ADCCON0, #0x07 ; Select channel 7
04D7            253   Average_ADC:
04D7 753E00     254            mov x+0, #low (0 % 0x10000) 
04DA 753F00     254            mov x+1, #high(0 % 0x10000) 
04DD 754000     254            mov x+2, #low (0 / 0x10000) 
04E0 754100     254            mov x+3, #high(0 / 0x10000) 
04E3 7D64       255            mov r5, #100
04E5            256   Sum_loop0:
04E5 1204B6     257            lcall Read_ADC
04E8            258       
04E8            259       ; Convert to voltage
04E8 8842       260            mov y+0, R0
04EA 8943       261            mov y+1, R1
04EC 754400     262            mov y+2, #0
04EF 754500     263            mov y+3, #0
04F2            264   
04F2 12023C     265            lcall add32
04F5 DDEE       266            djnz r5, Sum_loop0
04F7            267   
04F7 754264     268            mov y+0, #low (100 % 0x10000) 
04FA 754300     268            mov y+1, #high(100 % 0x10000) 
04FD 754400     268            mov y+2, #low (100 / 0x10000) 
0500 754500     268            mov y+3, #high(100 / 0x10000) 
0503 12037E     269            lcall div32
0506            270   
0506 7542C8     271            mov y+0, #low (51400 % 0x10000) 
0509 7543C8     271            mov y+1, #high(51400 % 0x10000) 
050C 754400     271            mov y+2, #low (51400 / 0x10000) 
050F 754500     271            mov y+3, #high(51400 / 0x10000)  ; VCC voltage measured
0512 1202F1     272            lcall mul32
0515 7542FF     273            mov y+0, #low (4095 % 0x10000) 
0518 75430F     273            mov y+1, #high(4095 % 0x10000) 
051B 754400     273            mov y+2, #low (4095 / 0x10000) 
051E 754500     273            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0521 12037E     274            lcall div32
0524            275   
0524 7542E8     276            mov y+0, #low (1000 % 0x10000) 
0527 754303     276            mov y+1, #high(1000 % 0x10000) 
052A 754400     276            mov y+2, #low (1000 / 0x10000) 
052D 754500     276            mov y+3, #high(1000 / 0x10000) 
0530 1202F1     277            lcall mul32
0533            278   
0533 754264     279            mov y+0, #low (100 % 0x10000) 
0536 754300     279            mov y+1, #high(100 % 0x10000) 
0539 754400     279            mov y+2, #low (100 / 0x10000) 
053C 754500     279            mov y+3, #high(100 / 0x10000) 
053F 1202F1     280            lcall mul32
0542            281   
0542 75421D     282            mov y+0, #low (90909 % 0x10000) 
0545 754363     282            mov y+1, #high(90909 % 0x10000) 
0548 754401     282            mov y+2, #low (90909 / 0x10000) 
054B 754500     282            mov y+3, #high(90909 / 0x10000) 
054E 12037E     283            lcall div32
0551            284   
0551 754229     285            mov y+0, #low (41 % 0x10000) 
0554 754300     285            mov y+1, #high(41 % 0x10000) 
0557 754400     285            mov y+2, #low (41 / 0x10000) 
055A 754500     285            mov y+3, #high(41 / 0x10000) 
055D 12037E     286            lcall div32
0560            287   
0560 754214     288            mov y+0, #low (20 % 0x10000) 
0563 754300     288            mov y+1, #high(20 % 0x10000) 
0566 754400     288            mov y+2, #low (20 / 0x10000) 
0569 754500     288            mov y+3, #high(20 / 0x10000) 
056C 12023C     289            lcall add32
056F            290   
056F 754210     291            mov y+0, #low (10000 % 0x10000) 
0572 754327     291            mov y+1, #high(10000 % 0x10000) 
0575 754400     291            mov y+2, #low (10000 / 0x10000) 
0578 754500     291            mov y+3, #high(10000 / 0x10000) 
057B 1202F1     292            lcall mul32
057E            293   
057E            294            ; Convert to BCD and display
057E 120177     295            lcall hex2bcd
0581            296            ;Set_Cursor(1, 13)
0581            297            ;Display_BCD(bcd+3)
0581            298            ;Display_BCD(bcd+2)
0581            299            ;Display_char(#'.')
0581            300            ;Display_BCD(bcd+1)
0581            301            ;Display_BCD(bcd+0)
0581            302            
0581            303            ; Wait 50 ms between conversions
0581 7A32       304            mov R2, #50
0583 1205DD     305            lcall waitms
0586            306   
0586 22         307            ret
0587            308   
0587            309   ;------------------------------------;
0587            310   ; Check for pushbutton press         ;
0587            311   ;------------------------------------;
0587            312   LCD_PB:
0587            313            ; Set variables to 1: 'no push button pressed'
0587 D200       314            setb PB0
0589 D201       315            setb PB1
058B D202       316            setb PB2
058D D203       317            setb PB3
058F D204       318            setb PB4
0591            319            ; The input pin used to check set to '1'
0591 D295       320            setb P1.5
0593            321            
0593            322            ; Check if any push button is pressed
0593 C280       323            clr P0.0
0595 C281       324            clr P0.1
0597 C282       325            clr P0.2
0599 C283       326            clr P0.3
059B C293       327            clr P1.3
059D 20953C     328            jb P1.5, LCD_PB_Done
05A0            329   
05A0            330            ; Debounce
05A0 7A32       331            mov R2, #50
05A2 1205DD     332            lcall waitms
05A5 209534     333            jb P1.5, LCD_PB_Done
05A8            334   
05A8            335            ; Set the LCD data pins to logic 1
05A8 D280       336            setb P0.0
05AA D281       337            setb P0.1
05AC D282       338            setb P0.2
05AE D283       339            setb P0.3
05B0 D293       340            setb P1.3
05B2            341            
05B2            342            ; Check the push buttons one by one
05B2 C293       343            clr P1.3
05B4 A295       344            mov c, P1.5
05B6 9200       345            mov PB0, c
05B8 D293       346            setb P1.3
05BA            347   
05BA C280       348            clr P0.0
05BC A295       349            mov c, P1.5
05BE 9201       350            mov PB1, c
05C0 D280       351            setb P0.0
05C2            352            
05C2 C281       353            clr P0.1
05C4 A295       354            mov c, P1.5
05C6 9202       355            mov PB2, c
05C8 D281       356            setb P0.1
05CA            357            
05CA C282       358            clr P0.2
05CC A295       359            mov c, P1.5
05CE 9203       360            mov PB3, c
05D0 D282       361            setb P0.2
05D2            362            
05D2 C283       363            clr P0.3
05D4 A295       364            mov c, P1.5
05D6 9204       365            mov PB4, c
05D8 D283       366            setb P0.3
05DA            367   
05DA            368            ; If a button was pressed, set the flag
05DA 7B01       369            mov R3, #1
05DC            370   
05DC            371   LCD_PB_Done:             
05DC 22         372            ret
05DD            373   
05DD            374   ;---------------------------------;
05DD            375   ; Wait 'R2' milliseconds          ;
05DD            376   ;---------------------------------;
05DD            377   waitms:
05DD C000       378       push AR0
05DF C001       379       push AR1
05E1 7928       380   L6: mov R1, #40
05E3 7868       381   L5: mov R0, #104
05E5 D8FE       382   L4: djnz R0, L4 ; 4 cycles->4*60.24ns*104=25.0us
05E7 D9FA       383       djnz R1, L5 ; 25us*40=1.0ms
05E9 DAF6       384       djnz R2, L6 ; number of millisecons to wait passed in R2
05EB D001       385       pop AR1
05ED D000       386       pop AR0
05EF 22         387       ret
05F0            388   
05F0            389   
05F0            390   ; Main program code begins here!
05F0            391   initialize:
05F0            392   
05F0            393            ;;;;;;;;;;;;;;;;;;;
05F0            394            ;; CONFIGURATION ;;
05F0            395            ;;;;;;;;;;;;;;;;;;;
05F0            396   
05F0            397            ; Configure all the pins for biderectional I/O
05F0 75AC00     398            mov     P3M1, #0x00
05F3 75AD00     399            mov     P3M2, #0x00
05F6 75B300     400            mov     P1M1, #0x00
05F9 75B400     401            mov     P1M2, #0x00
05FC 75B100     402            mov     P0M1, #0x00
05FF 75B200     403            mov     P0M2, #0x00
0602            404   
0602            405            ; The following code initializes the serial port
0602 438E10     406            orl     CKCON, #0x10 ; CLK is the input for timer 1
0605 438780     407            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0608 759852     408            mov     SCON, #0x52
060B 53C4DF     409            anl     T3CON, #0b11011111
060E 53890F     410            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0611 438920     411            orl     TMOD, #0x20 ; Timer 1 Mode 2
0614 758DF7     412            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0617 D28E       413            setb TR1
0619            414   
0619            415            ; Initialize the pin used by the ADC (P1.1) as input.
0619 43B302     416            orl     P1M1, #0b00000010
061C 53B4FD     417            anl     P1M2, #0b11111101
061F            418            
061F            419            ; Initialize and start the ADC:
061F 53E8F0     420            anl ADCCON0, #0xF0
0622 43E807     421            orl ADCCON0, #0x07 ; Select channel 7
0625            422            ; AINDIDS select if some pins are analog inputs or digital I/O:
0625 75F600     423            mov AINDIDS, #0x00 ; Disable all analog inputs
0628 43F680     424            orl AINDIDS, #0b10000000 ; P1.1 is analog input
062B 43E101     425            orl ADCCON1, #0x01 ; Enable ADC
062E            426            
062E            427            ; Initialize the Timers
062E 1203E7     428       lcall Timer0_Init ; Timer 1 (used to play noise from the speaker)
0631 12040A     429       lcall Timer2_Init ; Timer 2 (used to trigger an ISR every 1 second)
0634            430   
0634            431            ; Initialize the LCD - Toggle the 'E' pin
0634 1200FE     432       lcall LCD_4BIT ; Initialize the LCD display in 4 bit mode
0637            433            ;cpl TR0 ; toggle timer 0 immediately, or else it will make noise right away!
0637            434   
0637            435            ; Display the initial strings
0637 C0E0       436            push acc
0639 7401       436            mov a, #1
063B 14         436            dec a
063C 12013E     436            lcall ?Set_Cursor_1 ; Select column and row
063F D0E0       436            pop acc
0641 C083       437            push dph
0643 C082       437            push dpl
0645 C0E0       437            push acc
0647 90002E     437            mov dptr, #initial_msg1
064A 120131     437            lcall ?Send_Constant_String
064D D0E0       437            pop acc
064F D082       437            pop dpl
0651 D083       437            pop dph
0653            438   
0653 C0E0       439            push acc
0655 7401       439            mov a, #1
0657 14         439            dec a
0658 12013C     439            lcall ?Set_Cursor_2 ; Select column and row
065B D0E0       439            pop acc
065D C083       440            push dph
065F C082       440            push dpl
0661 C0E0       440            push acc
0663 90003F     440            mov dptr, #initial_mgs2
0666 120131     440            lcall ?Send_Constant_String
0669 D0E0       440            pop acc
066B D082       440            pop dpl
066D D083       440            pop dph
066F            441            
066F            442            ; Set the following variables to zero on startup
066F 7400       443            mov a, #0x0
0671 D4         444            da a
0672 F53B       445            mov current_state, a
0674 F505       446            mov display_time, a
0676 7430       447            mov a, #0x30
0678 D4         448            da a
0679 F532       449            mov soak_temp, a
067B 7460       450            mov a, #0x60
067D D4         451            da a
067E F534       452            mov soak_time, a
0680 7400       453            mov a, #0x00
0682 D4         454            da a
0683 F536       455            mov reflow_temp, a
0685 7445       456            mov a, #0x45
0687 D4         457            da a
0688 F538       458            mov reflow_time, a
068A            459   
068A            460   
068A            461   ;;;;;;;;;;;;;;;;;;;;;;;;
068A            462   ; FINITE STATE MACHINE ;
068A            463   ;;;;;;;;;;;;;;;;;;;;;;;;
068A            464   
068A            465   ; Start of the finite state machine
068A            466   FSM1: 
068A 753B00     467            mov current_state , #0x00
068D            468   
068D            469   
068D            470   ; STATE 0 - Off State (power 0%)
068D            471   off_state:
068D            472             
068D D2CA       473            setb TR2 ; Start Timer 2
068F            474   
068F 753D00     475            mov pwm, #0 ; set the oven power to 0 in this state
0692            476            
0692 C207       477            clr cooling_done
0694 D206       478            setb next_state ; play sound out of the speaker 
0696            479   
0696            480            ; set the initial values on the screen
0696 C0E0       481            push acc
0698 7403       481            mov a, #3
069A 14         481            dec a
069B 12013C     481            lcall ?Set_Cursor_2 ; Select column and row
069E D0E0       481            pop acc ; display the initial soak temperature
06A0 C000       482            push ar0
06A2 A832       482            mov r0, soak_temp+0
06A4 120143     482            lcall ?Display_BCD
06A7 D000       482            pop ar0
06A9            483   
06A9 C0E0       484            push acc
06AB 7407       484            mov a, #7
06AD 14         484            dec a
06AE 12013C     484            lcall ?Set_Cursor_2 ; Select column and row
06B1 D0E0       484            pop acc ; display the initial soak time
06B3 C000       485            push ar0
06B5 A834       485            mov r0, soak_time+0
06B7 120143     485            lcall ?Display_BCD
06BA D000       485            pop ar0
06BC            486   
06BC C0E0       487            push acc
06BE 740B       487            mov a, #11
06C0 14         487            dec a
06C1 12013C     487            lcall ?Set_Cursor_2 ; Select column and row
06C4 D0E0       487            pop acc
06C6            487    ; display the initial reflow temperature
06C6 C000       488            push ar0
06C8 A836       488            mov r0, reflow_temp+0
06CA 120143     488            lcall ?Display_BCD
06CD D000       488            pop ar0
06CF            489   
06CF C0E0       490            push acc
06D1 740E       490            mov a, #14
06D3 14         490            dec a
06D4 12013C     490            lcall ?Set_Cursor_2 ; Select column and row
06D7 D0E0       490            pop acc ; display the initial reflow time
06D9 C000       491            push ar0
06DB A838       491            mov r0, reflow_time+0
06DD 120143     491            lcall ?Display_BCD
06E0 D000       491            pop ar0
06E2            492   
06E2            493            ; we first want the user to set the soak temperature
06E2            494            soak_temp_button:
06E2 120587     495            lcall LCD_PB ; check for pushbutton presses
06E5 7A32       496            mov r2, #50
06E7 1205DD     497            lcall waitms
06EA 120587     498            lcall LCD_PB 
06ED            499            
06ED 300008     500            jnb PB0, inc_soak_temp ; if the increment button is pressed
06F0 300112     501            jnb PB1, dec_soak_temp ; if the decrement button is pressed
06F3 300235     502            jnb PB2, soak_time_button ; if the next button is pressed
06F6 801E       503            sjmp display_soak_temp ; check button presses again
06F8            504   
06F8            505            inc_soak_temp:
06F8 E532       506            mov a, soak_temp+0
06FA 2401       507            add a, #0x01
06FC D4         508            da a
06FD B47012     509            cjne a, #0x70, continue1
0700 753230     510            mov soak_temp+0, #0x30
0703 8011       511            sjmp display_soak_temp
0705            512   
0705            513            dec_soak_temp:
0705 E532       514            mov a, soak_temp+0
0707 2499       515            add a, #0x99
0709 D4         516            da a
070A B42905     517            cjne a, #0x29, continue1
070D 753270     518            mov soak_temp+0, #0x70
0710 8004       519            sjmp display_soak_temp
0712            520   
0712            521            continue1:
0712 F532       522            mov soak_temp+0, a
0714 8000       523            sjmp display_soak_temp
0716            524            
0716            525            display_soak_temp:
0716 C0E0       526            push acc
0718 7403       526            mov a, #3
071A 14         526            dec a
071B 12013C     526            lcall ?Set_Cursor_2 ; Select column and row
071E D0E0       526            pop acc ; display the current soak temperature
0720 C000       527            push ar0
0722 A832       527            mov r0, soak_temp+0
0724 120143     527            lcall ?Display_BCD
0727 D000       527            pop ar0
0729 80B7       528            sjmp soak_temp_button
072B            529   
072B            530            ; next we want to user the set the soak time (in seconds)
072B            531            soak_time_button:
072B 120587     532            lcall LCD_PB ; check for pushbutton presses
072E 7A32       533            mov r2, #50
0730 1205DD     534            lcall waitms
0733 120587     535            lcall LCD_PB
0736            536            
0736 300008     537            jnb PB0, inc_soak_time ; if the increment button is pressed
0739 30010E     538            jnb PB1, dec_soak_time ; if the decrement button is pressed
073C 300227     539            jnb PB2, reflow_temp_button ; if the next button is pressed
073F 8010       540            sjmp display_soak_time ; check button presses again
0741            541   
0741            542            inc_soak_time:
0741 E534       543            mov a, soak_time+0 
0743 2401       544            add a, #0x01
0745 D4         545            da a
0746 F534       546            mov soak_time, a
0748 8007       547            sjmp display_soak_time
074A            548   
074A            549            dec_soak_time:
074A E534       550            mov a, soak_time+0
074C 2499       551            add a, #0x99
074E D4         552            da a
074F F534       553            mov soak_time, a
0751            554            
0751            555            display_soak_time:
0751 C0E0       556            push acc
0753 7407       556            mov a, #7
0755 14         556            dec a
0756 12013C     556            lcall ?Set_Cursor_2 ; Select column and row
0759 D0E0       556            pop acc ; display the current soak time
075B C000       557            push ar0
075D A834       557            mov r0, soak_time+0
075F 120143     557            lcall ?Display_BCD
0762 D000       557            pop ar0
0764 80C5       558            sjmp soak_time_button
0766            559   
0766            560            ; third, we want the user to set the reflow temperature 
0766            561            reflow_temp_button:
0766 120587     562            lcall LCD_PB ; check for pushbutton presses
0769 7A32       563            mov r2, #50
076B 1205DD     564            lcall waitms
076E 120587     565            lcall LCD_PB
0771            566            
0771 300008     567            jnb PB0, inc_reflow_temp ; if the increment button is pressed
0774 300114     568            jnb PB1, dec_reflow_temp ; if the decrement button is pressed
0777 300239     569            jnb PB2, reflow_time_button ; if the next button is pressed
077A 80EA       570            sjmp reflow_temp_button ; check button presses again
077C            571   
077C            572            inc_reflow_temp:
077C E536       573            mov a, reflow_temp+0
077E 2401       574            add a, #0x01
0780 D4         575            da a
0781 B45014     576            cjne a, #0x50, continue3
0784 753600     577            mov reflow_temp+0, #0x00
0787 F536       578            mov reflow_temp+0, a
0789 8013       579            sjmp display_reflow_temp
078B            580   
078B            581            dec_reflow_temp:
078B E536       582            mov a, reflow_temp
078D 2499       583            add a, #0x99
078F D4         584            da a
0790 B45005     585            cjne a, #0x50, continue3
0793 753650     586            mov reflow_temp+0, #0x50
0796 8006       587            sjmp display_reflow_temp
0798            588   
0798            589            continue3:
0798 F536       590            mov reflow_temp+0, a
079A 8002       591            sjmp display_reflow_temp
079C F536       592            mov reflow_temp+0, a 
079E            593   
079E            594            display_reflow_temp:
079E C0E0       595            push acc
07A0 740B       595            mov a, #11
07A2 14         595            dec a
07A3 12013C     595            lcall ?Set_Cursor_2 ; Select column and row
07A6 D0E0       595            pop acc ; display the current reflow temperature
07A8 C000       596            push ar0
07AA A836       596            mov r0, reflow_temp+0
07AC 120143     596            lcall ?Display_BCD
07AF D000       596            pop ar0
07B1 80B3       597            sjmp reflow_temp_button
07B3            598   
07B3            599            ; finally, we want the user to set the reflow time 
07B3            600            reflow_time_button:
07B3 120587     601            lcall LCD_PB ; check for pushbutton presses
07B6 7A32       602            mov r2, #50
07B8 1205DD     603            lcall waitms
07BB 120587     604            lcall LCD_PB
07BE            605            
07BE 300008     606            jnb PB0, inc_reflow_time ; if the increment button is pressed
07C1 300112     607            jnb PB1, dec_reflow_time ; if the decrement button is pressed
07C4 300237     608            jnb PB2, wait_for_start ; if the next button is pressed
07C7 80EA       609            sjmp reflow_time_button ; check button presses again
07C9            610   
07C9            611            inc_reflow_time:
07C9 E538       612            mov a, reflow_time
07CB 2401       613            add a, #0x01
07CD D4         614            da a
07CE B48012     615            cjne a, #0x80, continue4
07D1 753840     616            mov reflow_time, #0x40
07D4 8013       617            sjmp display_reflow_time
07D6            618   
07D6            619            dec_reflow_time:
07D6 E538       620            mov a, reflow_time
07D8 2499       621            add a, #0x99
07DA D4         622            da a
07DB B43905     623            cjne a, #0x39, continue4
07DE 753880     624            mov reflow_time, #0x80
07E1 8006       625            sjmp display_reflow_time
07E3            626   
07E3            627            continue4:
07E3 F538       628            mov reflow_time, a
07E5 8002       629            sjmp display_reflow_time
07E7 F538       630            mov reflow_time, a 
07E9            631   
07E9            632            display_reflow_time:
07E9 C0E0       633            push acc
07EB 740E       633            mov a, #14
07ED 14         633            dec a
07EE 12013C     633            lcall ?Set_Cursor_2 ; Select column and row
07F1 D0E0       633            pop acc ; display the current reflow time
07F3 C000       634            push ar0
07F5 A838       634            mov r0, reflow_time
07F7 120143     634            lcall ?Display_BCD
07FA D000       634            pop ar0
07FC 80B5       635            sjmp reflow_time_button 
07FE            636   
07FE            637            ; if we reach this label, all paramters have been set
07FE            638            ; we are now waiting for the user to press the start/stop button (PB4) to begin
07FE            639            wait_for_start:
07FE 120587     640            lcall LCD_PB ; check for pushbuttons presses
0801 7A32       641            mov r2, #50
0803 1205DD     642            lcall waitms
0806 120587     643            lcall LCD_PB
0809 2004F2     644            jb PB4, wait_for_start ; infinite loop if the start button is not pressed
080C 02080F     645            ljmp preheat_state
080F            646            ;mov current_state, #1 ; if the start button is pressed, move to state 1 (preheat)
080F            647   
080F            648   
080F            649   ; STATE 1 - Preheat State (increase temperature to soak_temp - power 100%), check for it to reach over 50 C within 60 seconds
080F            650   preheat_state:
080F            651   
080F 7401       652            mov a, #0x01
0811 1200F9     652            lcall ?WriteCommand ; clear the LCD
0814 C0E0       653            push acc
0816 7401       653            mov a, #1
0818 14         653            dec a
0819 12013E     653            lcall ?Set_Cursor_1 ; Select column and row
081C D0E0       653            pop acc
081E C083       654            push dph
0820 C082       654            push dpl
0822 C0E0       654            push acc
0824 90002E     654            mov dptr, #initial_msg1
0827 120131     654            lcall ?Send_Constant_String
082A D0E0       654            pop acc
082C D082       654            pop dpl
082E D083       654            pop dph
0830 753D64     655            mov pwm, #100 ; set the oven power to 100% in this state
0833            656   
0833            657            ; reset the state_time
0833 E4         658            clr a
0834 F53A       659            mov state_time, a
0836 D206       660            setb next_state
0838 D205       661            setb display_time
083A            662   
083A            663            ; display the working message string
083A C0E0       664            push acc
083C 7401       664            mov a, #1
083E 14         664            dec a
083F 12013C     664            lcall ?Set_Cursor_2 ; Select column and row
0842 D0E0       664            pop acc
0844 C083       665            push dph
0846 C082       665            push dpl
0848 C0E0       665            push acc
084A 900050     665            mov dptr, #preheat_mgs
084D 120131     665            lcall ?Send_Constant_String
0850 D0E0       665            pop acc
0852 D082       665            pop dpl
0854 D083       665            pop dph
0856            666   
0856 853242     667            mov y+0, soak_temp+0
0859 853343     668            mov y+1, soak_temp+1
085C 754400     669            mov y+2, #0
085F 754500     670            mov y+3, #0
0862            671   
0862            672            ; check if the current temperature is equal to the user set soak temperature
0862            673            check_soak_temp:
0862 1204D1     674            lcall Read_Temp 
0865 12029B     675            lcall x_gt_y ; sets the mf bit if x > y
0868 200827     676            jb mf, preheat_state_done ; if we have reached the soak_temp, check for an error 
086B            677   
086B            678            ; check if the current temperature is less than 50 degrees
086B            679            check_for_error:
086B 754232     680            mov y+0, #low (50 % 0x10000) 
086E 754300     680            mov y+1, #high(50 % 0x10000) 
0871 754400     680            mov y+2, #low (50 / 0x10000) 
0874 754500     680            mov y+3, #high(50 / 0x10000) 
0877 12029B     681            lcall x_gt_y ; check if the current temperature is greater than 50 degrees
087A 2008E5     682            jb mf, check_soak_temp ; if we are over 50 degrees, check the temperature again
087D            683   
087D            684            ; if the current temperature is less than 50 degrees, check the state time
087D            685            error: 
087D E53A       686            mov a, state_time
087F 943C       687            subb a, #60
0881 4003       688            jc soak_not_reached ; if less than 60 seconds have passed, we have not reached the termination condition
0883 02068D     689            ljmp off_state ; if at least 60 seconds have passed, we must terminate the program 
0886            690   
0886            691            ; if we are not ready to procede to soak, check the stop button
0886            692            soak_not_reached:
0886            693   
0886 120587     694            lcall LCD_PB ; check for pushbutton presses
0889 2004D6     695            jb PB4, check_soak_temp 
088C 753B00     696            mov current_state, #0 ; if the stop button is pressed, return to state 0
088F 02068D     697            ljmp off_state
0892            698   
0892            699            preheat_state_done: 
0892 753B02     700            mov current_state, #2
0895            701   
0895            702   
0895            703   ; STATE 2 - Soak State (maintain temperature - power 20%)
0895            704   soak_state: 
0895            705   
0895 E53B       706            mov a, current_state
0897 B4025C     707            cjne a, #2, ramp_state ; if current state is not 0, move to state 1
089A 753D14     708            mov pwm, #20 ; set the oven power to 20% in this state
089D            709   
089D 7401       710            mov a, #0x01
089F 1200F9     710            lcall ?WriteCommand ; clear the LCD
08A2 C0E0       711            push acc
08A4 7401       711            mov a, #1
08A6 14         711            dec a
08A7 12013E     711            lcall ?Set_Cursor_1 ; Select column and row
08AA D0E0       711            pop acc
08AC C083       712            push dph
08AE C082       712            push dpl
08B0 C0E0       712            push acc
08B2 90002E     712            mov dptr, #initial_msg1
08B5 120131     712            lcall ?Send_Constant_String
08B8 D0E0       712            pop acc
08BA D082       712            pop dpl
08BC D083       712            pop dph
08BE            713            ; display the working message string
08BE C0E0       714            push acc
08C0 7401       714            mov a, #1
08C2 14         714            dec a
08C3 12013C     714            lcall ?Set_Cursor_2 ; Select column and row
08C6 D0E0       714            pop acc
08C8 C083       715            push dph
08CA C082       715            push dpl
08CC C0E0       715            push acc
08CE 900061     715            mov dptr, #soak_mgs
08D1 120131     715            lcall ?Send_Constant_String
08D4 D0E0       715            pop acc
08D6 D082       715            pop dpl
08D8 D083       715            pop dph
08DA            716   
08DA            717            ; reset the state_time
08DA E4         718            clr a
08DB F53A       719            mov state_time, a
08DD D206       720            setb next_state
08DF            721            
08DF            722            ; check if the state_time is equal to the user set soak_time
08DF            723            check_soak_time:
08DF E53A       724            mov a, state_time
08E1 9534       725            subb a, soak_time
08E3 4002       726            jc  ramp_not_reached ; if have not yet hit then soak_time, check if the stop button has been pressed
08E5 500C       727            jnc soak_state_done ; if the state_time is equal or greater to the soak_time, proceed to the ramp state
08E7            728   
08E7            729            ; if we are not ready to procede to ramp to reflow, check the stop button
08E7            730            ramp_not_reached:
08E7 120587     731            lcall LCD_PB ; check for pushbutton presses
08EA 2004F2     732            jb PB4, check_soak_time 
08ED 753B00     733            mov current_state, #0 ; if the stop button is pressed, return to state 0
08F0 02068D     734            ljmp off_state 
08F3            735   
08F3            736            soak_state_done:
08F3 753B03     737            mov current_state, #3
08F6            738   
08F6            739   
08F6            740   ; STATE 3 - Ramp to Reflow State (increase temperature to reflow_temp - power 100%)      
08F6            741   ramp_state:
08F6            742   
08F6 E53B       743            mov a, current_state
08F8 B40341     744            cjne a, #3, reflow_state ; if current state is not 3, move to state 4
08FB 753D64     745            mov pwm, #100 ; set the oven power to 100% in this state
08FE            746            
08FE            747            ; reset the state_time
08FE E4         748            clr a
08FF F53A       749            mov state_time, a
0901 D206       750            setb next_state
0903            751   
0903            752            ; display the working message string
0903 C0E0       753            push acc
0905 7401       753            mov a, #1
0907 14         753            dec a
0908 12013C     753            lcall ?Set_Cursor_2 ; Select column and row
090B D0E0       753            pop acc
090D C083       754            push dph
090F C082       754            push dpl
0911 C0E0       754            push acc
0913 900072     754            mov dptr, #ramp_mgs
0916 120131     754            lcall ?Send_Constant_String
0919 D0E0       754            pop acc
091B D082       754            pop dpl
091D D083       754            pop dph
091F            755   
091F            756   
091F            757            check_ramp_temp: 
091F            758            ; fetch the current temperature 
091F 1204D1     759            lcall Read_Temp
0922            760            ; moving the bcd value into current_temp
0922 854039     761            mov current_temp, x+2
0925            762   
0925            763            ; check if the current temperature is equal to the user set soak temperature
0925 E539       764            mov a, current_temp
0927 9536       765            subb a, reflow_temp
0929 4002       766            jc reflow_not_reached ; if have not yet hit the reflow temperature, check if the stop button is pressed
092B 500C       767            jnc ramp_state_done  ; if the current temperature is equal or greater to the reflow_temp, the ramp state is done
092D            768   
092D            769            ; if we are not ready to procede to reflow, check the stop button
092D            770            reflow_not_reached:
092D 120587     771            lcall LCD_PB ; check for pushbutton presses
0930 2004EC     772            jb PB4, check_ramp_temp 
0933 753B00     773            mov current_state, #0 ; if the stop button is pressed, return to state 0
0936 02068D     774            ljmp off_state
0939            775   
0939            776            ramp_state_done: 
0939 753B04     777            mov current_state, #4
093C            778   
093C            779   
093C            780   
093C            781   ; STATE 4 - Reflow State (maintain temperature - power 20%)
093C            782   reflow_state:
093C            783   
093C E53B       784            mov a, current_state
093E B4043B     785            cjne a, #4, cooling ; if current state is not 4, move to state 5
0941 753D14     786            mov pwm, #20 ; set the oven power to 20% in this state
0944            787   
0944            788            ; reset the state_time
0944 E4         789            clr a
0945 F53A       790            mov state_time, a
0947 D206       791            setb next_state
0949            792   
0949            793            ; display the working message string
0949 C0E0       794            push acc
094B 7401       794            mov a, #1
094D 14         794            dec a
094E 12013C     794            lcall ?Set_Cursor_2 ; Select column and row
0951 D0E0       794            pop acc
0953 C083       795            push dph
0955 C082       795            push dpl
0957 C0E0       795            push acc
0959 900083     795            mov dptr, #reflow_mgs
095C 120131     795            lcall ?Send_Constant_String
095F D0E0       795            pop acc
0961 D082       795            pop dpl
0963 D083       795            pop dph
0965            796   
0965            797            ; check if the state_time is equal to the user set reflow_time
0965            798            check_reflow_time:
0965 E53A       799            mov a, state_time
0967 9538       800            subb a, reflow_time
0969 4002       801            jc  cooling_not_reached ; if we have not yet hit the reflow_time, check if the stop button has been pressed
096B 500C       802            jnc reflow_state_done ; if the state_time is equal or greater to the reflow_time, proceed to the cooling state
096D            803   
096D            804            ; if we are not ready to procede to ramp to reflow, check the stop button
096D            805            cooling_not_reached:
096D 120587     806            lcall LCD_PB ; check for pushbutton presses
0970 2004F2     807            jb PB4, check_reflow_time 
0973 753B00     808            mov current_state, #0 ; if the stop button is pressed, return to state 0
0976 02068D     809            ljmp off_state 
0979            810   
0979            811            reflow_state_done:
0979 753B05     812            mov current_state, #5
097C            813   
097C            814   
097C            815   ; STATE 5 - Cooling (power fully off)
097C            816   cooling:
097C            817   
097C 753D00     818            mov pwm, #0 ; set the oven power to 0% in this state
097F            819   
097F            820            ; display the working message string
097F C0E0       821            push acc
0981 7401       821            mov a, #1
0983 14         821            dec a
0984 12013C     821            lcall ?Set_Cursor_2 ; Select column and row
0987 D0E0       821            pop acc
0989 C083       822            push dph
098B C082       822            push dpl
098D C0E0       822            push acc
098F 900094     822            mov dptr, #cooling_mgs
0992 120131     822            lcall ?Send_Constant_String
0995 D0E0       822            pop acc
0997 D082       822            pop dpl
0999 D083       822            pop dph
099B            823   
099B            824            ; reset the state_time
099B E4         825            clr a
099C F53A       826            mov state_time, a
099E D206       827            setb next_state
09A0            828   
09A0            829            check_cooling_temp: 
09A0            830            ; fetch the current temperature 
09A0 1204D1     831            lcall Read_Temp
09A3            832            ; moving the bcd value into current_temp
09A3 854839     833            mov current_temp, bcd+2
09A6            834   
09A6            835            ; check if the current temperature is equal to the user set soak temperature
09A6 E539       836            mov a, current_temp
09A8 943C       837            subb a, #60
09AA 4002       838            jc cooling_state_done ; if the current temperature is less than 60 degrees, we have finished the cooling stage
09AC 50F2       839            jnc check_cooling_temp  ; if the current temperature is greater than or equal to 60 degrees, check the temperature again
09AE            840   
09AE            841            cooling_state_done:
09AE 753B00     842            mov current_state, #0
09B1 C205       843            clr display_time
09B3 753A00     844            mov state_time, #0
09B6            845   
09B6            846            loop:
09B6 E53A       847            mov a, state_time
09B8 9406       848            subb a, #6 ; wait 6 seconds - 2 second period for each speaker play
09BA 40FA       849            jc loop ; condition not yet met
09BC 02068D     850            ljmp off_state ; FSM done 
