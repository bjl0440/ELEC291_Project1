0000              1   ; Implementation of the finite state machine to control the stages of the reflow oven
0000              2   
                  4   $LIST
0000              6   
0000              7   ;  N76E003 pinout:
0000              8   ;                               -------
0000              9   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             10   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             11   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             12   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             13   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             14   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             15   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             16   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             17   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             18   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             19   ;                               -------
0000             20   ;
0000             21   
0000             22   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD          EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER0_RATE   EQU 2048     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             25   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             27   TIMER2_RATE   EQU 100      ; 100Hz or 10ms
0000             28   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 2 input divide to 16 in T2MOD
0000             29   
0000             30   ; Relevant vectors
0000             31   ; Reset vector
0000             32   org 0x0000
0000 02061E      33       ljmp initialize
0003             34   
0003             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 0203FD      37            ljmp Timer0_ISR
000E             38   
000E             39   ; Timer/Counter 2 overflow interrupt vector
002B             40   org 0x002B
002B 020427      41            ljmp Timer2_ISR
002E             42            
002E             43            
002E             44   ;;;;;;;;;;;;
002E             45   ;   PINS   ;
002E             46   ;;;;;;;;;;;;
002E             47      
002E             48   LCD_RS     equ P1.3
002E             49   ;LCD_RW    equ PX.X  ; Not used in this code, connect the pin to GND
002E             50   LCD_E      equ P1.4
002E             51   LCD_D4     equ P0.0
002E             52   LCD_D5     equ P0.1
002E             53   LCD_D6     equ P0.2
002E             54   LCD_D7     equ P0.3   
002E             55   PWM_OUT    equ P1.0 ; Toggles power to the oven (Logic 1=oven on)
002E             56   SOUND_OUT  equ P0.4 ; Speaker connection 
002E             57   
002E             58   ; Decleration of one byte current state variable and parameters
0030             59   DSEG at 0x30
0030             60   Count1ms:      ds 2 ; Used to determine when a second has passed
0032             61   soak_temp:     ds 2 ; User set variable for the desired soak temperature
0034             62   soak_time:     ds 2 ; User set variable for the length of the soak time
0036             63   reflow_temp:   ds 2 ; User set variable for the reflow temperature
0038             64   reflow_time:   ds 1 ; User set variable for timein the reflow state
0039             65   current_temp:  ds 1 ; Current temperature in the oven
003A             66   state_time:    ds 1 ; Current amount of time we have been in a given state
003B             67   current_state: ds 1 ; Current state of the finite state machine
003C             68   pwm_counter:   ds 1 ; Free running counter 0, 1, 2, ..., 100, 0 used for PWM purposes
003D             69   pwm:           ds 1 ; pwm percentage variable - adjust as needed in each state
003E             70   
003E             71   ;for math_32.inc library
003E             72   x:   ds 4
0042             73   y:   ds 4
0046             74   bcd: ds 5
004B             75   
004B             76   ; decleration of one bit variables (flags)
0000             77   BSEG
0000             78   ; These one bit variables store the value of the pushbuttons after calling 'LCD_PB' 
0000             79   PB0:                dbit 1 ; incremement (INC)
0001             80   PB1:                dbit 1 ; decremement (DEC)
0002             81   PB2:                dbit 1 ; next parameter (NXT)
0003             82   PB3:                dbit 1 ; currently unused (PB3)
0004             83   PB4:                dbit 1 ; start / emergency stop (EMR)
0005             84   display_time:  dbit 1 ; if this flag is set, we want to start displaying the state time
0006             85   next_state:    dbit 1 ; if this flag is set, we want to make a speaker beep
0007             86   cooling_done:  dbit 1 ; flag set if cooling state is finished
0008             87   mf:            dbit 1 ; used for math functions  
0009             88   
002E             89   CSEG
002E             90   
002E             91   ; Strings
002E             92   ;                '1234567890123456'
002E 546F3D20    93   initial_msg1: DB 'To=   C  Tj=20C ',0
     20204320
     20546A3D
     32304320
     00
003F 73312020    94   initial_mgs2: DB 's1  ,   r2  ,   ',0
     2C202020
     72322020
     2C202020
     00
0050             95   ;         s=soak temp, soak time   r=reflow temp,reflow time
0050             96   
0050             97   ;state name messages
0050             98   ;                '1234567890123456'
0050 743D2020    99   preheat_mgs: DB    't=       Preheat',0
     20202020
     20507265
     68656174
     00
0061 743D2020   100   soak_mgs:    DB    't=       Soaking',0
     20202020
     20536F61
     6B696E67
     00
0072 743D2020   101   ramp_mgs:    DB    't=          Ramp',0
     20202020
     20202020
     52616D70
     00
0083 743D2020   102   reflow_mgs:  DB    't=        Reflow',0
     20202020
     20205265
     666C6F77
     00
0094 743D2020   103   cooling_mgs: DB    't=       Cooling',0
     20202020
     20436F6F
     6C696E67
     00
00A5            104   
00A5            105   
00A5            106   ; A library of LCD related functions and utility macros
                108   $LIST
0159            110   
0159            111   ; A library of math related functions and utility macros
                579   $LIST
                113   $LIST
03E7            115   
03E7            116   ; Initialization of timers
03E7            117   ;---------------------------------;
03E7            118   ; Routine to initialize the ISR   ;
03E7            119   ; for timer 0                     ;
03E7            120   ;---------------------------------;
03E7            121   Timer0_Init:
03E7 438E08     122            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03EA E589       123            mov a, TMOD
03EC 54F0       124            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03EE 4401       125            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03F0 F589       126            mov TMOD, a
03F2 758CE0     127            mov TH0, #high(TIMER0_RELOAD)
03F5 758A57     128            mov TL0, #low(TIMER0_RELOAD)
03F8            129            ; Enable the timer and interrupts
03F8 D2A9       130       setb ET0  ; Enable timer 0 interrupt
03FA D28C       131       setb TR0  ; Start timer 0
03FC 22         132            ret
03FD            133   
03FD            134   ;---------------------------------;
03FD            135   ; ISR for timer 0.  Set to execute;
03FD            136   ; every 1/2048Hz to generate a    ;
03FD            137   ; 2048 Hz wave at pin SOUND_OUT   ;
03FD            138   ;---------------------------------;
03FD            139   Timer0_ISR:
03FD            140            ;clr TF0  ; According to the data sheet this is done for us already.
03FD            141            ; Timer 0 doesn't have 16-bit auto-reload, so
03FD C28C       142            clr TR0
03FF 758CE0     143            mov TH0, #high(TIMER0_RELOAD)
0402 758A57     144            mov TL0, #low(TIMER0_RELOAD)
0405 D28C       145            setb TR0
0407 B284       146            cpl SOUND_OUT ; Toggles the speaker pin at 1000 Hz to play noise
0409 32         147            reti
040A            148   
040A            149   ;---------------------------------;
040A            150   ; Routine to initialize the ISR   ;
040A            151   ; for timer 2                     ;
040A            152   ;---------------------------------;
040A            153   Timer2_Init:
040A            154            ; Initialize timer 2 for periodic interrupts
040A 75C800     155            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
040D 75CDD7     156            mov TH2, #high(TIMER2_RELOAD)
0410 75CC79     157            mov TL2, #low(TIMER2_RELOAD)
0413            158            ; Set the reload value
0413 75C9A0     159            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0416 75CBD7     160            mov RCMP2H, #high(TIMER2_RELOAD)
0419 75CA79     161            mov RCMP2L, #low(TIMER2_RELOAD)
041C            162            ; Init the free running 10 ms counter to zero
041C 753C00     163            mov pwm_counter, #0
041F            164            ; Enable the timer and interrupts
041F 439B80     165            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0422 D2CA       166       setb TR2  ; Enable timer 2
0424 D2AF       167            setb EA ; Enable global interrupts
0426            168   
0426 22         169            ret 
0427            170   
0427            171   ;---------------------------------;
0427            172   ; ISR for timer 2                 ;
0427            173   ;---------------------------------;
0427            174   Timer2_ISR:
0427 C2CF       175            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0429 C0D0       176            push psw
042B C0E0       177            push acc
042D            178            
042D 053C       179            inc pwm_counter
042F C3         180            clr c
0430 E53D       181            mov a, pwm
0432 953C       182            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0434 B3         183            cpl c
0435 9290       184            mov PWM_OUT, c
0437            185            
0437 E53C       186            mov a, pwm_counter
0439 B46433     187            cjne a, #100, Timer2_ISR_done ; check if 1000 ms have passed
043C 753C00     188            mov pwm_counter, #0
043F 053A       189            inc state_time ; It is super easy to keep a seconds count here
0441            190   
0441 300518     191            jnb display_time, new_state_noise ; if we are in at least the pre-heat state, begin showing state time on the LCD       Set_Cursor(2,3)
0444 E53A       192            mov a, state_time
0446 D4         193            da a 
0447 F53A       194            mov state_time, a 
0449 C0E0       195            push acc
044B 7403       195            mov a, #3
044D 14         195            dec a
044E 12013C     195            lcall ?Set_Cursor_2 ; Select column and row
0451 D0E0       195            pop acc
0453            195   
0453 C000       196            push ar0
0455 A83A       196            mov r0, state_time
0457 120143     196            lcall ?Display_BCD
045A D000       196            pop ar0
045C            197   
045C            198            new_state_noise:
045C 300607     199            jnb next_state, send_serial ; if we are not entering a new state, jump to the send serial port code
045F B28C       200            cpl TR0 ; Enable/disable timer/counter 0. This line enables the beep sound from the speaker when we enter a new state
0461 200702     201            jb cooling_done, send_serial ; if cooling is done, we play the sound 3 times
0464 C206       202            clr next_state
0466            203   
0466            204            send_serial:
0466 C000       205            push ar0
0468 A83E       205            mov r0, x
046A 120161     205            lcall ?Send_BCD
046D D000       205            pop ar0 ; Assuming the current temperature is stored in a byte of x
046F            206   
046F            207   Timer2_ISR_done:
046F D0E0       208            pop acc
0471 D0D0       209            pop psw
0473 32         210            reti
0474            211   
0474            212   ; Function declearations begins here:
0474            213   ; We can display a number any way we want.  In this case with four decimal places.
0474            214   Display_formated_BCD:
0474 C0E0       215            push acc
0476 7405       215            mov a, #5
0478 14         215            dec a
0479 12013C     215            lcall ?Set_Cursor_2 ; Select column and row
047C D0E0       215            pop acc
047E C000       216            push ar0
0480 A84A       216            mov r0, bcd+4
0482 120143     216            lcall ?Display_BCD
0485 D000       216            pop ar0
0487 C000       217            push ar0
0489 A849       217            mov r0, bcd+3
048B 120143     217            lcall ?Display_BCD
048E D000       217            pop ar0
0490 C000       218            push ar0
0492 A848       218            mov r0, bcd+2
0494 120143     218            lcall ?Display_BCD
0497 D000       218            pop ar0
0499            219            ;Display_char(#'.')
0499 C000       220            push ar0
049B A847       220            mov r0, bcd+1
049D 120143     220            lcall ?Display_BCD
04A0 D000       220            pop ar0
04A2 C000       221            push ar0
04A4 A846       221            mov r0, bcd+0
04A6 120143     221            lcall ?Display_BCD
04A9 D000       221            pop ar0
04AB C0E0       222            push acc
04AD 7406       222            mov a, #6
04AF 14         222            dec a
04B0 12013C     222            lcall ?Set_Cursor_2 ; Select column and row
04B3 D0E0       222            pop acc
04B5            223            
04B5 22         224            ret
04B6            225   
04B6            226   Read_ADC:
04B6 C2EF       227            clr ADCF
04B8 D2EE       228            setb ADCS ;  ADC start trigger signal
04BA 30EFFD     229       jnb ADCF, $ ; Wait for conversion complete
04BD            230       
04BD            231       ; Read the ADC result and store in [R1, R0]
04BD E5C2       232       mov a, ADCRL
04BF 540F       233       anl a, #0x0f
04C1 F8         234       mov R0, a
04C2 E5C3       235       mov a, ADCRH   
04C4 C4         236       swap a
04C5 C0E0       237       push acc
04C7 540F       238       anl a, #0x0f
04C9 F9         239       mov R1, a
04CA D0E0       240       pop acc
04CC 54F0       241       anl a, #0xf0
04CE 48         242       orl a, R0
04CF F8         243       mov R0, A
04D0 22         244            ret
04D1            245   
04D1            246   
04D1            247   ; this function reads the overall temperature
04D1            248   ; (cold + hot) junction and turns the value in bcd
04D1            249   Read_Temp:
04D1            250            ; Read the signal connected to AIN7
04D1 53E8F0     251            anl ADCCON0, #0xF0
04D4 43E807     252            orl ADCCON0, #0x07 ; Select channel 7
04D7            253   Average_ADC:
04D7 753E00     254            mov x+0, #low (0 % 0x10000) 
04DA 753F00     254            mov x+1, #high(0 % 0x10000) 
04DD 754000     254            mov x+2, #low (0 / 0x10000) 
04E0 754100     254            mov x+3, #high(0 / 0x10000) 
04E3 7D64       255            mov r5, #100
04E5            256   Sum_loop0:
04E5 1204B6     257            lcall Read_ADC
04E8            258       
04E8            259       ; Convert to voltage
04E8 8842       260            mov y+0, R0
04EA 8943       261            mov y+1, R1
04EC 754400     262            mov y+2, #0
04EF 754500     263            mov y+3, #0
04F2            264   
04F2 12023C     265            lcall add32
04F5 DDEE       266            djnz r5, Sum_loop0
04F7            267   
04F7 754264     268            mov y+0, #low (100 % 0x10000) 
04FA 754300     268            mov y+1, #high(100 % 0x10000) 
04FD 754400     268            mov y+2, #low (100 / 0x10000) 
0500 754500     268            mov y+3, #high(100 / 0x10000) 
0503 12037E     269            lcall div32
0506            270   
0506 7542C8     271            mov y+0, #low (51400 % 0x10000) 
0509 7543C8     271            mov y+1, #high(51400 % 0x10000) 
050C 754400     271            mov y+2, #low (51400 / 0x10000) 
050F 754500     271            mov y+3, #high(51400 / 0x10000)  ; VCC voltage measured
0512 1202F1     272            lcall mul32
0515 7542FF     273            mov y+0, #low (4095 % 0x10000) 
0518 75430F     273            mov y+1, #high(4095 % 0x10000) 
051B 754400     273            mov y+2, #low (4095 / 0x10000) 
051E 754500     273            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0521 12037E     274            lcall div32
0524            275   
0524 7542E8     276            mov y+0, #low (1000 % 0x10000) 
0527 754303     276            mov y+1, #high(1000 % 0x10000) 
052A 754400     276            mov y+2, #low (1000 / 0x10000) 
052D 754500     276            mov y+3, #high(1000 / 0x10000) 
0530 1202F1     277            lcall mul32
0533            278   
0533 754264     279            mov y+0, #low (100 % 0x10000) 
0536 754300     279            mov y+1, #high(100 % 0x10000) 
0539 754400     279            mov y+2, #low (100 / 0x10000) 
053C 754500     279            mov y+3, #high(100 / 0x10000) 
053F 1202F1     280            lcall mul32
0542            281   
0542 75421D     282            mov y+0, #low (90909 % 0x10000) 
0545 754363     282            mov y+1, #high(90909 % 0x10000) 
0548 754401     282            mov y+2, #low (90909 / 0x10000) 
054B 754500     282            mov y+3, #high(90909 / 0x10000) 
054E 12037E     283            lcall div32
0551            284   
0551 754229     285            mov y+0, #low (41 % 0x10000) 
0554 754300     285            mov y+1, #high(41 % 0x10000) 
0557 754400     285            mov y+2, #low (41 / 0x10000) 
055A 754500     285            mov y+3, #high(41 / 0x10000) 
055D 12037E     286            lcall div32
0560            287   
0560 754214     288            mov y+0, #low (20 % 0x10000) 
0563 754300     288            mov y+1, #high(20 % 0x10000) 
0566 754400     288            mov y+2, #low (20 / 0x10000) 
0569 754500     288            mov y+3, #high(20 / 0x10000) 
056C 12023C     289            lcall add32
056F            290   
056F 754210     291            mov y+0, #low (10000 % 0x10000) 
0572 754327     291            mov y+1, #high(10000 % 0x10000) 
0575 754400     291            mov y+2, #low (10000 / 0x10000) 
0578 754500     291            mov y+3, #high(10000 / 0x10000) 
057B 1202F1     292            lcall mul32
057E            293   
057E            294            ; Convert to BCD and display
057E 120177     295            lcall hex2bcd
0581 C0E0       296            push acc
0583 740D       296            mov a, #13
0585 14         296            dec a
0586 12013E     296            lcall ?Set_Cursor_1 ; Select column and row
0589 D0E0       296            pop acc
058B C000       297            push ar0
058D A849       297            mov r0, bcd+3
058F 120143     297            lcall ?Display_BCD
0592 D000       297            pop ar0
0594 C000       298            push ar0
0596 A848       298            mov r0, bcd+2
0598 120143     298            lcall ?Display_BCD
059B D000       298            pop ar0
059D C0E0       299            push acc
059F 742E       299            mov a, #'.'
05A1 1200F4     299            lcall ?WriteData
05A4 D0E0       299            pop acc
05A6 C000       300            push ar0
05A8 A847       300            mov r0, bcd+1
05AA 120143     300            lcall ?Display_BCD
05AD D000       300            pop ar0
05AF            301            ;Display_BCD(bcd+0)
05AF            302            
05AF            303            ; Wait 50 ms between conversions
05AF 7A32       304            mov R2, #50
05B1 12060B     305            lcall waitms
05B4            306   
05B4 22         307            ret
05B5            308   
05B5            309   ;------------------------------------;
05B5            310   ; Check for pushbutton press         ;
05B5            311   ;------------------------------------;
05B5            312   LCD_PB:
05B5            313            ; Set variables to 1: 'no push button pressed'
05B5 D200       314            setb PB0
05B7 D201       315            setb PB1
05B9 D202       316            setb PB2
05BB D203       317            setb PB3
05BD D204       318            setb PB4
05BF            319            ; The input pin used to check set to '1'
05BF D295       320            setb P1.5
05C1            321            
05C1            322            ; Check if any push button is pressed
05C1 C280       323            clr P0.0
05C3 C281       324            clr P0.1
05C5 C282       325            clr P0.2
05C7 C283       326            clr P0.3
05C9 C293       327            clr P1.3
05CB 20953C     328            jb P1.5, LCD_PB_Done
05CE            329   
05CE            330            ; Debounce
05CE 7A32       331            mov R2, #50
05D0 12060B     332            lcall waitms
05D3 209534     333            jb P1.5, LCD_PB_Done
05D6            334   
05D6            335            ; Set the LCD data pins to logic 1
05D6 D280       336            setb P0.0
05D8 D281       337            setb P0.1
05DA D282       338            setb P0.2
05DC D283       339            setb P0.3
05DE D293       340            setb P1.3
05E0            341            
05E0            342            ; Check the push buttons one by one
05E0 C293       343            clr P1.3
05E2 A295       344            mov c, P1.5
05E4 9200       345            mov PB0, c
05E6 D293       346            setb P1.3
05E8            347   
05E8 C280       348            clr P0.0
05EA A295       349            mov c, P1.5
05EC 9201       350            mov PB1, c
05EE D280       351            setb P0.0
05F0            352            
05F0 C281       353            clr P0.1
05F2 A295       354            mov c, P1.5
05F4 9202       355            mov PB2, c
05F6 D281       356            setb P0.1
05F8            357            
05F8 C282       358            clr P0.2
05FA A295       359            mov c, P1.5
05FC 9203       360            mov PB3, c
05FE D282       361            setb P0.2
0600            362            
0600 C283       363            clr P0.3
0602 A295       364            mov c, P1.5
0604 9204       365            mov PB4, c
0606 D283       366            setb P0.3
0608            367   
0608            368            ; If a button was pressed, set the flag
0608 7B01       369            mov R3, #1
060A            370   
060A            371   LCD_PB_Done:             
060A 22         372            ret
060B            373   
060B            374   ;---------------------------------;
060B            375   ; Wait 'R2' milliseconds          ;
060B            376   ;---------------------------------;
060B            377   waitms:
060B C000       378       push AR0
060D C001       379       push AR1
060F 7928       380   L6: mov R1, #40
0611 7868       381   L5: mov R0, #104
0613 D8FE       382   L4: djnz R0, L4 ; 4 cycles->4*60.24ns*104=25.0us
0615 D9FA       383       djnz R1, L5 ; 25us*40=1.0ms
0617 DAF6       384       djnz R2, L6 ; number of millisecons to wait passed in R2
0619 D001       385       pop AR1
061B D000       386       pop AR0
061D 22         387       ret
061E            388   
061E            389   
061E            390   ; Main program code begins here!
061E            391   initialize:
061E            392   
061E            393            ;;;;;;;;;;;;;;;;;;;
061E            394            ;; CONFIGURATION ;;
061E            395            ;;;;;;;;;;;;;;;;;;;
061E            396   
061E            397            ; Configure all the pins for biderectional I/O
061E 75AC00     398            mov     P3M1, #0x00
0621 75AD00     399            mov     P3M2, #0x00
0624 75B300     400            mov     P1M1, #0x00
0627 75B400     401            mov     P1M2, #0x00
062A 75B100     402            mov     P0M1, #0x00
062D 75B200     403            mov     P0M2, #0x00
0630            404   
0630            405            ; The following code initializes the serial port
0630 438E10     406            orl     CKCON, #0x10 ; CLK is the input for timer 1
0633 438780     407            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0636 759852     408            mov     SCON, #0x52
0639 53C4DF     409            anl     T3CON, #0b11011111
063C 53890F     410            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
063F 438920     411            orl     TMOD, #0x20 ; Timer 1 Mode 2
0642 758DF7     412            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0645 D28E       413            setb TR1
0647            414   
0647            415            ; Initialize the pin used by the ADC (P1.1) as input.
0647 43B302     416            orl     P1M1, #0b00000010
064A 53B4FD     417            anl     P1M2, #0b11111101
064D            418            
064D            419            ; Initialize and start the ADC:
064D 53E8F0     420            anl ADCCON0, #0xF0
0650 43E807     421            orl ADCCON0, #0x07 ; Select channel 7
0653            422            ; AINDIDS select if some pins are analog inputs or digital I/O:
0653 75F600     423            mov AINDIDS, #0x00 ; Disable all analog inputs
0656 43F680     424            orl AINDIDS, #0b10000000 ; P1.1 is analog input
0659 43E101     425            orl ADCCON1, #0x01 ; Enable ADC
065C            426            
065C            427            ; Initialize the Timers
065C 1203E7     428       lcall Timer0_Init ; Timer 1 (used to play noise from the speaker)
065F 12040A     429       lcall Timer2_Init ; Timer 2 (used to trigger an ISR every 1 second)
0662            430   
0662            431            ; Initialize the LCD - Toggle the 'E' pin
0662 1200FE     432       lcall LCD_4BIT ; Initialize the LCD display in 4 bit mode
0665            433            ;cpl TR0 ; toggle timer 0 immediately, or else it will make noise right away!
0665            434   
0665            435            ; Display the initial strings
0665 C0E0       436            push acc
0667 7401       436            mov a, #1
0669 14         436            dec a
066A 12013E     436            lcall ?Set_Cursor_1 ; Select column and row
066D D0E0       436            pop acc
066F C083       437            push dph
0671 C082       437            push dpl
0673 C0E0       437            push acc
0675 90002E     437            mov dptr, #initial_msg1
0678 120131     437            lcall ?Send_Constant_String
067B D0E0       437            pop acc
067D D082       437            pop dpl
067F D083       437            pop dph
0681            438   
0681 C0E0       439            push acc
0683 7401       439            mov a, #1
0685 14         439            dec a
0686 12013C     439            lcall ?Set_Cursor_2 ; Select column and row
0689 D0E0       439            pop acc
068B C083       440            push dph
068D C082       440            push dpl
068F C0E0       440            push acc
0691 90003F     440            mov dptr, #initial_mgs2
0694 120131     440            lcall ?Send_Constant_String
0697 D0E0       440            pop acc
0699 D082       440            pop dpl
069B D083       440            pop dph
069D            441            
069D            442            ; Set the following variables to zero on startup
069D 7400       443            mov a, #0x0
069F D4         444            da a
06A0 F53B       445            mov current_state, a
06A2 F505       446            mov display_time, a
06A4 7430       447            mov a, #0x30
06A6 D4         448            da a
06A7 F532       449            mov soak_temp, a
06A9 7460       450            mov a, #0x60
06AB D4         451            da a
06AC F534       452            mov soak_time, a
06AE 7400       453            mov a, #0x00
06B0 D4         454            da a
06B1 F536       455            mov reflow_temp, a
06B3 7445       456            mov a, #0x45
06B5 D4         457            da a
06B6 F538       458            mov reflow_time, a
06B8            459   
06B8            460   
06B8            461   ;;;;;;;;;;;;;;;;;;;;;;;;
06B8            462   ; FINITE STATE MACHINE ;
06B8            463   ;;;;;;;;;;;;;;;;;;;;;;;;
06B8            464   
06B8            465   ; Start of the finite state machine
06B8            466   FSM1: 
06B8 753B00     467            mov current_state , #0x00
06BB            468   
06BB            469   
06BB            470   ; STATE 0 - Off State (power 0%)
06BB            471   off_state:
06BB            472             
06BB D2CA       473            setb TR2 ; Start Timer 2
06BD            474   
06BD 753D00     475            mov pwm, #0 ; set the oven power to 0 in this state
06C0            476            
06C0 C207       477            clr cooling_done
06C2 D206       478            setb next_state ; play sound out of the speaker 
06C4            479   
06C4            480            ; set the initial values on the screen
06C4 C0E0       481            push acc
06C6 7403       481            mov a, #3
06C8 14         481            dec a
06C9 12013C     481            lcall ?Set_Cursor_2 ; Select column and row
06CC D0E0       481            pop acc ; display the initial soak temperature
06CE C000       482            push ar0
06D0 A832       482            mov r0, soak_temp+0
06D2 120143     482            lcall ?Display_BCD
06D5 D000       482            pop ar0
06D7            483   
06D7 C0E0       484            push acc
06D9 7407       484            mov a, #7
06DB 14         484            dec a
06DC 12013C     484            lcall ?Set_Cursor_2 ; Select column and row
06DF D0E0       484            pop acc ; display the initial soak time
06E1 C000       485            push ar0
06E3 A834       485            mov r0, soak_time+0
06E5 120143     485            lcall ?Display_BCD
06E8 D000       485            pop ar0
06EA            486   
06EA C0E0       487            push acc
06EC 740B       487            mov a, #11
06EE 14         487            dec a
06EF 12013C     487            lcall ?Set_Cursor_2 ; Select column and row
06F2 D0E0       487            pop acc
06F4            487    ; display the initial reflow temperature
06F4 C000       488            push ar0
06F6 A836       488            mov r0, reflow_temp+0
06F8 120143     488            lcall ?Display_BCD
06FB D000       488            pop ar0
06FD            489   
06FD C0E0       490            push acc
06FF 740E       490            mov a, #14
0701 14         490            dec a
0702 12013C     490            lcall ?Set_Cursor_2 ; Select column and row
0705 D0E0       490            pop acc ; display the initial reflow time
0707 C000       491            push ar0
0709 A838       491            mov r0, reflow_time+0
070B 120143     491            lcall ?Display_BCD
070E D000       491            pop ar0
0710            492   
0710            493            ; we first want the user to set the soak temperature
0710            494            soak_temp_button:
0710 1205B5     495            lcall LCD_PB ; check for pushbutton presses
0713 7A32       496            mov r2, #50
0715 12060B     497            lcall waitms
0718 1205B5     498            lcall LCD_PB 
071B            499            
071B 300008     500            jnb PB0, inc_soak_temp ; if the increment button is pressed
071E 300112     501            jnb PB1, dec_soak_temp ; if the decrement button is pressed
0721 300235     502            jnb PB2, soak_time_button ; if the next button is pressed
0724 801E       503            sjmp display_soak_temp ; check button presses again
0726            504   
0726            505            inc_soak_temp:
0726 E532       506            mov a, soak_temp+0
0728 2401       507            add a, #0x01
072A D4         508            da a
072B B47012     509            cjne a, #0x70, continue1
072E 753230     510            mov soak_temp+0, #0x30
0731 8011       511            sjmp display_soak_temp
0733            512   
0733            513            dec_soak_temp:
0733 E532       514            mov a, soak_temp+0
0735 2499       515            add a, #0x99
0737 D4         516            da a
0738 B42905     517            cjne a, #0x29, continue1
073B 753270     518            mov soak_temp+0, #0x70
073E 8004       519            sjmp display_soak_temp
0740            520   
0740            521            continue1:
0740 F532       522            mov soak_temp+0, a
0742 8000       523            sjmp display_soak_temp
0744            524            
0744            525            display_soak_temp:
0744 C0E0       526            push acc
0746 7403       526            mov a, #3
0748 14         526            dec a
0749 12013C     526            lcall ?Set_Cursor_2 ; Select column and row
074C D0E0       526            pop acc ; display the current soak temperature
074E C000       527            push ar0
0750 A832       527            mov r0, soak_temp+0
0752 120143     527            lcall ?Display_BCD
0755 D000       527            pop ar0
0757 80B7       528            sjmp soak_temp_button
0759            529   
0759            530            ; next we want to user the set the soak time (in seconds)
0759            531            soak_time_button:
0759 1205B5     532            lcall LCD_PB ; check for pushbutton presses
075C 7A32       533            mov r2, #50
075E 12060B     534            lcall waitms
0761 1205B5     535            lcall LCD_PB
0764            536            
0764 300008     537            jnb PB0, inc_soak_time ; if the increment button is pressed
0767 30010E     538            jnb PB1, dec_soak_time ; if the decrement button is pressed
076A 300227     539            jnb PB2, reflow_temp_button ; if the next button is pressed
076D 8010       540            sjmp display_soak_time ; check button presses again
076F            541   
076F            542            inc_soak_time:
076F E534       543            mov a, soak_time+0 
0771 2401       544            add a, #0x01
0773 D4         545            da a
0774 F534       546            mov soak_time, a
0776 8007       547            sjmp display_soak_time
0778            548   
0778            549            dec_soak_time:
0778 E534       550            mov a, soak_time+0
077A 2499       551            add a, #0x99
077C D4         552            da a
077D F534       553            mov soak_time, a
077F            554            
077F            555            display_soak_time:
077F C0E0       556            push acc
0781 7407       556            mov a, #7
0783 14         556            dec a
0784 12013C     556            lcall ?Set_Cursor_2 ; Select column and row
0787 D0E0       556            pop acc ; display the current soak time
0789 C000       557            push ar0
078B A834       557            mov r0, soak_time+0
078D 120143     557            lcall ?Display_BCD
0790 D000       557            pop ar0
0792 80C5       558            sjmp soak_time_button
0794            559   
0794            560            ; third, we want the user to set the reflow temperature 
0794            561            reflow_temp_button:
0794 1205B5     562            lcall LCD_PB ; check for pushbutton presses
0797 7A32       563            mov r2, #50
0799 12060B     564            lcall waitms
079C 1205B5     565            lcall LCD_PB
079F            566            
079F 300008     567            jnb PB0, inc_reflow_temp ; if the increment button is pressed
07A2 300114     568            jnb PB1, dec_reflow_temp ; if the decrement button is pressed
07A5 300239     569            jnb PB2, reflow_time_button ; if the next button is pressed
07A8 80EA       570            sjmp reflow_temp_button ; check button presses again
07AA            571   
07AA            572            inc_reflow_temp:
07AA E536       573            mov a, reflow_temp+0
07AC 2401       574            add a, #0x01
07AE D4         575            da a
07AF B45014     576            cjne a, #0x50, continue3
07B2 753600     577            mov reflow_temp+0, #0x00
07B5 F536       578            mov reflow_temp+0, a
07B7 8013       579            sjmp display_reflow_temp
07B9            580   
07B9            581            dec_reflow_temp:
07B9 E536       582            mov a, reflow_temp
07BB 2499       583            add a, #0x99
07BD D4         584            da a
07BE B45005     585            cjne a, #0x50, continue3
07C1 753650     586            mov reflow_temp+0, #0x50
07C4 8006       587            sjmp display_reflow_temp
07C6            588   
07C6            589            continue3:
07C6 F536       590            mov reflow_temp+0, a
07C8 8002       591            sjmp display_reflow_temp
07CA F536       592            mov reflow_temp+0, a 
07CC            593   
07CC            594            display_reflow_temp:
07CC C0E0       595            push acc
07CE 740B       595            mov a, #11
07D0 14         595            dec a
07D1 12013C     595            lcall ?Set_Cursor_2 ; Select column and row
07D4 D0E0       595            pop acc ; display the current reflow temperature
07D6 C000       596            push ar0
07D8 A836       596            mov r0, reflow_temp+0
07DA 120143     596            lcall ?Display_BCD
07DD D000       596            pop ar0
07DF 80B3       597            sjmp reflow_temp_button
07E1            598   
07E1            599            ; finally, we want the user to set the reflow time 
07E1            600            reflow_time_button:
07E1 1205B5     601            lcall LCD_PB ; check for pushbutton presses
07E4 7A32       602            mov r2, #50
07E6 12060B     603            lcall waitms
07E9 1205B5     604            lcall LCD_PB
07EC            605            
07EC 300008     606            jnb PB0, inc_reflow_time ; if the increment button is pressed
07EF 300112     607            jnb PB1, dec_reflow_time ; if the decrement button is pressed
07F2 300237     608            jnb PB2, wait_for_start ; if the next button is pressed
07F5 80EA       609            sjmp reflow_time_button ; check button presses again
07F7            610   
07F7            611            inc_reflow_time:
07F7 E538       612            mov a, reflow_time
07F9 2401       613            add a, #0x01
07FB D4         614            da a
07FC B48012     615            cjne a, #0x80, continue4
07FF 753840     616            mov reflow_time, #0x40
0802 8013       617            sjmp display_reflow_time
0804            618   
0804            619            dec_reflow_time:
0804 E538       620            mov a, reflow_time
0806 2499       621            add a, #0x99
0808 D4         622            da a
0809 B43905     623            cjne a, #0x39, continue4
080C 753880     624            mov reflow_time, #0x80
080F 8006       625            sjmp display_reflow_time
0811            626   
0811            627            continue4:
0811 F538       628            mov reflow_time, a
0813 8002       629            sjmp display_reflow_time
0815 F538       630            mov reflow_time, a 
0817            631   
0817            632            display_reflow_time:
0817 C0E0       633            push acc
0819 740E       633            mov a, #14
081B 14         633            dec a
081C 12013C     633            lcall ?Set_Cursor_2 ; Select column and row
081F D0E0       633            pop acc ; display the current reflow time
0821 C000       634            push ar0
0823 A838       634            mov r0, reflow_time
0825 120143     634            lcall ?Display_BCD
0828 D000       634            pop ar0
082A 80B5       635            sjmp reflow_time_button 
082C            636   
082C            637            ; if we reach this label, all paramters have been set
082C            638            ; we are now waiting for the user to press the start/stop button (PB4) to begin
082C            639            wait_for_start:
082C 1205B5     640            lcall LCD_PB ; check for pushbuttons presses
082F 7A32       641            mov r2, #50
0831 12060B     642            lcall waitms
0834 1205B5     643            lcall LCD_PB
0837 2004F2     644            jb PB4, wait_for_start ; infinite loop if the start button is not pressed
083A 02083D     645            ljmp preheat_state
083D            646            ;mov current_state, #1 ; if the start button is pressed, move to state 1 (preheat)
083D            647   
083D            648   
083D            649   ; STATE 1 - Preheat State (increase temperature to soak_temp - power 100%), check for it to reach over 50 C within 60 seconds
083D            650   preheat_state:
083D            651   
083D 7401       652            mov a, #0x01
083F 1200F9     652            lcall ?WriteCommand ; clear the LCD
0842 C0E0       653            push acc
0844 7401       653            mov a, #1
0846 14         653            dec a
0847 12013E     653            lcall ?Set_Cursor_1 ; Select column and row
084A D0E0       653            pop acc
084C C083       654            push dph
084E C082       654            push dpl
0850 C0E0       654            push acc
0852 90002E     654            mov dptr, #initial_msg1
0855 120131     654            lcall ?Send_Constant_String
0858 D0E0       654            pop acc
085A D082       654            pop dpl
085C D083       654            pop dph
085E 753D64     655            mov pwm, #100 ; set the oven power to 100% in this state
0861            656   
0861            657            ; reset the state_time
0861 E4         658            clr a
0862 F53A       659            mov state_time, a
0864 D206       660            setb next_state
0866 D205       661            setb display_time
0868            662   
0868            663            ; display the working message string
0868 C0E0       664            push acc
086A 7401       664            mov a, #1
086C 14         664            dec a
086D 12013C     664            lcall ?Set_Cursor_2 ; Select column and row
0870 D0E0       664            pop acc
0872 C083       665            push dph
0874 C082       665            push dpl
0876 C0E0       665            push acc
0878 900050     665            mov dptr, #preheat_mgs
087B 120131     665            lcall ?Send_Constant_String
087E D0E0       665            pop acc
0880 D082       665            pop dpl
0882 D083       665            pop dph
0884            666   
0884 853242     667            mov y+0, soak_temp+0
0887 853343     668            mov y+1, soak_temp+1
088A 754400     669            mov y+2, #0
088D 754500     670            mov y+3, #0
0890            671   
0890            672            ; check if the current temperature is equal to the user set soak temperature
0890            673            check_soak_temp:
0890 1204D1     674            lcall Read_Temp 
0893 12029B     675            lcall x_gt_y ; sets the mf bit if x > y
0896 200827     676            jb mf, preheat_state_done ; if we have reached the soak_temp, check for an error 
0899            677   
0899            678            ; check if the current temperature is less than 50 degrees
0899            679            check_for_error:
0899 754232     680            mov y+0, #low (50 % 0x10000) 
089C 754300     680            mov y+1, #high(50 % 0x10000) 
089F 754400     680            mov y+2, #low (50 / 0x10000) 
08A2 754500     680            mov y+3, #high(50 / 0x10000) 
08A5 12029B     681            lcall x_gt_y ; check if the current temperature is greater than 50 degrees
08A8 2008E5     682            jb mf, check_soak_temp ; if we are over 50 degrees, check the temperature again
08AB            683   
08AB            684            ; if the current temperature is less than 50 degrees, check the state time
08AB            685            error: 
08AB E53A       686            mov a, state_time
08AD 9460       687            subb a, #0x60
08AF 4003       688            jc soak_not_reached ; if less than 60 seconds have passed, we have not reached the termination condition
08B1 0206BB     689            ljmp off_state ; if at least 60 seconds have passed, we must terminate the program 
08B4            690   
08B4            691            ; if we are not ready to procede to soak, check the stop button
08B4            692            soak_not_reached:
08B4            693   
08B4 1205B5     694            lcall LCD_PB ; check for pushbutton presses
08B7 2004D6     695            jb PB4, check_soak_temp 
08BA 753B00     696            mov current_state, #0 ; if the stop button is pressed, return to state 0
08BD 0206BB     697            ljmp off_state
08C0            698   
08C0            699            preheat_state_done: 
08C0 753B02     700            mov current_state, #2
08C3            701   
08C3            702   
08C3            703   ; STATE 2 - Soak State (maintain temperature - power 20%)
08C3            704   soak_state: 
08C3            705   
08C3 E53B       706            mov a, current_state
08C5 B4025F     707            cjne a, #2, ramp_state ; if current state is not 0, move to state 1
08C8 753D14     708            mov pwm, #20 ; set the oven power to 20% in this state
08CB            709   
08CB 7401       710            mov a, #0x01
08CD 1200F9     710            lcall ?WriteCommand ; clear the LCD
08D0 C0E0       711            push acc
08D2 7401       711            mov a, #1
08D4 14         711            dec a
08D5 12013E     711            lcall ?Set_Cursor_1 ; Select column and row
08D8 D0E0       711            pop acc
08DA C083       712            push dph
08DC C082       712            push dpl
08DE C0E0       712            push acc
08E0 90002E     712            mov dptr, #initial_msg1
08E3 120131     712            lcall ?Send_Constant_String
08E6 D0E0       712            pop acc
08E8 D082       712            pop dpl
08EA D083       712            pop dph
08EC            713            ; display the working message string
08EC C0E0       714            push acc
08EE 7401       714            mov a, #1
08F0 14         714            dec a
08F1 12013C     714            lcall ?Set_Cursor_2 ; Select column and row
08F4 D0E0       714            pop acc
08F6 C083       715            push dph
08F8 C082       715            push dpl
08FA C0E0       715            push acc
08FC 900061     715            mov dptr, #soak_mgs
08FF 120131     715            lcall ?Send_Constant_String
0902 D0E0       715            pop acc
0904 D082       715            pop dpl
0906 D083       715            pop dph
0908            716   
0908            717            ; reset the state_time
0908 E4         718            clr a
0909 F53A       719            mov state_time, a
090B D206       720            setb next_state
090D            721            
090D            722            ; check if the state_time is equal to the user set soak_time
090D            723            check_soak_time:
090D 1204D1     724            lcall Read_Temp 
0910 E53A       725            mov a, state_time
0912 9534       726            subb a, soak_time
0914 4002       727            jc  ramp_not_reached ; if have not yet hit then soak_time, check if the stop button has been pressed
0916 500C       728            jnc soak_state_done ; if the state_time is equal or greater to the soak_time, proceed to the ramp state
0918            729   
0918            730            ; if we are not ready to procede to ramp to reflow, check the stop button
0918            731            ramp_not_reached:
0918 1205B5     732            lcall LCD_PB ; check for pushbutton presses
091B 2004EF     733            jb PB4, check_soak_time 
091E 753B00     734            mov current_state, #0 ; if the stop button is pressed, return to state 0
0921 0206BB     735            ljmp off_state 
0924            736   
0924            737            soak_state_done:
0924 753B03     738            mov current_state, #3
0927            739   
0927            740   
0927            741   ; STATE 3 - Ramp to Reflow State (increase temperature to reflow_temp - power 100%)      
0927            742   ramp_state:
0927            743   
0927 E53B       744            mov a, current_state
0929 B40341     745            cjne a, #3, reflow_state ; if current state is not 3, move to state 4
092C 753D64     746            mov pwm, #100 ; set the oven power to 100% in this state
092F            747            
092F            748            ; reset the state_time
092F E4         749            clr a
0930 F53A       750            mov state_time, a
0932 D206       751            setb next_state
0934            752   
0934            753            ; display the working message string
0934 C0E0       754            push acc
0936 7401       754            mov a, #1
0938 14         754            dec a
0939 12013C     754            lcall ?Set_Cursor_2 ; Select column and row
093C D0E0       754            pop acc
093E C083       755            push dph
0940 C082       755            push dpl
0942 C0E0       755            push acc
0944 900072     755            mov dptr, #ramp_mgs
0947 120131     755            lcall ?Send_Constant_String
094A D0E0       755            pop acc
094C D082       755            pop dpl
094E D083       755            pop dph
0950            756   
0950            757   
0950            758            check_ramp_temp: 
0950            759            ; fetch the current temperature 
0950 1204D1     760            lcall Read_Temp
0953            761            ; moving the bcd value into current_temp
0953 854039     762            mov current_temp, x+2
0956            763   
0956            764            ; check if the current temperature is equal to the user set soak temperature
0956 E539       765            mov a, current_temp
0958 9536       766            subb a, reflow_temp
095A 4002       767            jc reflow_not_reached ; if have not yet hit the reflow temperature, check if the stop button is pressed
095C 500C       768            jnc ramp_state_done  ; if the current temperature is equal or greater to the reflow_temp, the ramp state is done
095E            769   
095E            770            ; if we are not ready to procede to reflow, check the stop button
095E            771            reflow_not_reached:
095E 1205B5     772            lcall LCD_PB ; check for pushbutton presses
0961 2004EC     773            jb PB4, check_ramp_temp 
0964 753B00     774            mov current_state, #0 ; if the stop button is pressed, return to state 0
0967 0206BB     775            ljmp off_state
096A            776   
096A            777            ramp_state_done: 
096A 753B04     778            mov current_state, #4
096D            779   
096D            780   
096D            781   
096D            782   ; STATE 4 - Reflow State (maintain temperature - power 20%)
096D            783   reflow_state:
096D            784   
096D E53B       785            mov a, current_state
096F B4043B     786            cjne a, #4, cooling ; if current state is not 4, move to state 5
0972 753D14     787            mov pwm, #20 ; set the oven power to 20% in this state
0975            788   
0975            789            ; reset the state_time
0975 E4         790            clr a
0976 F53A       791            mov state_time, a
0978 D206       792            setb next_state
097A            793   
097A            794            ; display the working message string
097A C0E0       795            push acc
097C 7401       795            mov a, #1
097E 14         795            dec a
097F 12013C     795            lcall ?Set_Cursor_2 ; Select column and row
0982 D0E0       795            pop acc
0984 C083       796            push dph
0986 C082       796            push dpl
0988 C0E0       796            push acc
098A 900083     796            mov dptr, #reflow_mgs
098D 120131     796            lcall ?Send_Constant_String
0990 D0E0       796            pop acc
0992 D082       796            pop dpl
0994 D083       796            pop dph
0996            797   
0996            798            ; check if the state_time is equal to the user set reflow_time
0996            799            check_reflow_time:
0996 E53A       800            mov a, state_time
0998 9538       801            subb a, reflow_time
099A 4002       802            jc  cooling_not_reached ; if we have not yet hit the reflow_time, check if the stop button has been pressed
099C 500C       803            jnc reflow_state_done ; if the state_time is equal or greater to the reflow_time, proceed to the cooling state
099E            804   
099E            805            ; if we are not ready to procede to ramp to reflow, check the stop button
099E            806            cooling_not_reached:
099E 1205B5     807            lcall LCD_PB ; check for pushbutton presses
09A1 2004F2     808            jb PB4, check_reflow_time 
09A4 753B00     809            mov current_state, #0 ; if the stop button is pressed, return to state 0
09A7 0206BB     810            ljmp off_state 
09AA            811   
09AA            812            reflow_state_done:
09AA 753B05     813            mov current_state, #5
09AD            814   
09AD            815   
09AD            816   ; STATE 5 - Cooling (power fully off)
09AD            817   cooling:
09AD            818   
09AD 753D00     819            mov pwm, #0 ; set the oven power to 0% in this state
09B0            820   
09B0            821            ; display the working message string
09B0 C0E0       822            push acc
09B2 7401       822            mov a, #1
09B4 14         822            dec a
09B5 12013C     822            lcall ?Set_Cursor_2 ; Select column and row
09B8 D0E0       822            pop acc
09BA C083       823            push dph
09BC C082       823            push dpl
09BE C0E0       823            push acc
09C0 900094     823            mov dptr, #cooling_mgs
09C3 120131     823            lcall ?Send_Constant_String
09C6 D0E0       823            pop acc
09C8 D082       823            pop dpl
09CA D083       823            pop dph
09CC            824   
09CC            825            ; reset the state_time
09CC E4         826            clr a
09CD F53A       827            mov state_time, a
09CF D206       828            setb next_state
09D1            829   
09D1            830            check_cooling_temp: 
09D1            831            ; fetch the current temperature 
09D1 1204D1     832            lcall Read_Temp
09D4            833            ; moving the bcd value into current_temp
09D4 854839     834            mov current_temp, bcd+2
09D7            835   
09D7            836            ; check if the current temperature is equal to the user set soak temperature
09D7 E539       837            mov a, current_temp
09D9 943C       838            subb a, #60
09DB 4002       839            jc cooling_state_done ; if the current temperature is less than 60 degrees, we have finished the cooling stage
09DD 50F2       840            jnc check_cooling_temp  ; if the current temperature is greater than or equal to 60 degrees, check the temperature again
09DF            841   
09DF            842            cooling_state_done:
09DF 753B00     843            mov current_state, #0
09E2 C205       844            clr display_time
09E4 753A00     845            mov state_time, #0
09E7            846   
09E7            847            loop:
09E7 E53A       848            mov a, state_time
09E9 9406       849            subb a, #6 ; wait 6 seconds - 2 second period for each speaker play
09EB 40FA       850            jc loop ; condition not yet met
09ED 7401       851            mov a, #0x01
09EF 1200F9     851            lcall ?WriteCommand
09F2 0206BB     852            ljmp off_state ; FSM done 
