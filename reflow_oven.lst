0000              1   ; Implementation of the finite state machine to control the stages of the reflow oven
0000              2   
                  4   $LIST
0000              6   
0000              7   ;  N76E003 pinout:
0000              8   ;                               -------
0000              9   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000             10   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             11   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             12   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             13   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             14   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             15   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             16   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             17   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             18   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             19   ;                               -------
0000             20   ;
0000             21   
0000             22   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD          EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER0_RATE   EQU 2048     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             25   TIMER1_RELOAD EQU (0x100-(CLK/(16*BAUD)))
0000             26   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             27   TIMER2_RATE   EQU 100      ; 100Hz or 10ms
0000             28   TIMER2_RELOAD EQU (65536-(CLK/(16*TIMER2_RATE))) ; Need to change timer 2 input divide to 16 in T2MOD
0000             29   
0000             30   ; Relevant vectors
0000             31   ; Reset vector
0000             32   org 0x0000
0000 0205E6      33       ljmp initialize
0003             34   
0003             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 0203FD      37            ljmp Timer0_ISR
000E             38   
000E             39   ; Timer/Counter 2 overflow interrupt vector
002B             40   org 0x002B
002B 020427      41            ljmp Timer2_ISR
002E             42            
002E             43            
002E             44   ;;;;;;;;;;;;
002E             45   ;   PINS   ;
002E             46   ;;;;;;;;;;;;
002E             47      
002E             48   LCD_RS     equ P1.3
002E             49   ;LCD_RW    equ PX.X  ; Not used in this code, connect the pin to GND
002E             50   LCD_E      equ P1.4
002E             51   LCD_D4     equ P0.0
002E             52   LCD_D5     equ P0.1
002E             53   LCD_D6     equ P0.2
002E             54   LCD_D7     equ P0.3   
002E             55   PWM_OUT    equ P1.0 ; Toggles power to the oven (Logic 1=oven on)
002E             56   SOUND_OUT  equ P0.4 ; Speaker connection 
002E             57   
002E             58   ; Decleration of one byte current state variable and parameters
0030             59   DSEG at 0x30
0030             60   Count1ms:      ds 2 ; Used to determine when a second has passed
0032             61   soak_temp:     ds 1 ; User set variable for the desired soak temperature
0033             62   soak_time:     ds 2 ; User set variable for the length of the soak time
0035             63   current_soak_time: ds 2
0037             64   reflow_temp:   ds 2 ; User set variable for the reflow temperature
0039             65   reflow_time:   ds 1 ; User set variable for timein the reflow state
003A             66   current_temp:  ds 1 ; Current temperature in the oven
003B             67   current_time:  ds 1 ; Current time placeholder used for LCD purposes
003C             68   state_time:    ds 1 ; Current amount of time we have been in a given state
003D             69   current_state: ds 1 ; Current state of the finite state machine
003E             70   pwm_counter:   ds 1 ; Free running counter 0, 1, 2, ..., 100, 0 used for PWM purposes
003F             71   pwm:           ds 1 ; pwm percentage variable - adjust as needed in each state
0040             72   VLED_ADC: ds 2
0042             73   
0042             74   ;for math_32.inc library
0042             75   x:   ds 4
0046             76   y:   ds 4
004A             77   bcd: ds 5
004F             78   
004F             79   ; decleration of one bit variables (flags)
0000             80   BSEG
0000             81   ; These one bit variables store the value of the pushbuttons after calling 'LCD_PB' 
0000             82   PB0:                     dbit 1 ; incremement (INC)
0001             83   PB1:                     dbit 1 ; decremement (DEC)
0002             84   PB2:                     dbit 1 ; next parameter (NXT)
0003             85   PB3:                     dbit 1 ; currently unused (PB3)
0004             86   PB4:                     dbit 1 ; start / emergency stop (EMR)
0005             87   display_time:       dbit 1 ; if this flag is set, we want to start displaying the state time
0006             88   new_state:          dbit 1 ; if this flag is set, we want to make a speaker beep
0007             89   cooling_done:       dbit 1 ; flag set if cooling state is finished
0008             90   mf:                 dbit 1 ; used for math functions  
0009             91   one_second_flag:    dbit 1 ; set every 1 second, time displays, then cleared
000A             92   
002E             93   CSEG
002E             94   
002E             95   ; Strings
002E             96   ;                '1234567890123456'
002E 546F3D30    97   initial_msg1: DB 'To=020C   Tj=20C',0
     32304320
     2020546A
     3D323043
     00
003F 73312020    98   initial_mgs2: DB 's1  ,    r   ,  ',0
     2C202020
     20722020
     202C2020
     00
0050             99   ;         s=soak temp, soak time   r=reflow temp,reflow time
0050            100   
0050            101   ;state name messages
0050            102   ;                '1234567890123456'
0050 743D2020   103   preheat_mgs: DB    't=       Preheat',0
     20202020
     20507265
     68656174
     00
0061 743D2020   104   soak_mgs:    DB    't=       Soaking',0
     20202020
     20536F61
     6B696E67
     00
0072 743D2020   105   ramp_mgs:    DB    't=          Ramp',0
     20202020
     20202020
     52616D70
     00
0083 743D2020   106   reflow_mgs:  DB    't=        Reflow',0
     20202020
     20205265
     666C6F77
     00
0094 743D2020   107   cooling_mgs: DB    't=       Cooling',0
     20202020
     20436F6F
     6C696E67
     00
00A5            108   
00A5            109   
00A5            110   ; A library of LCD related functions and utility macros
                112   $LIST
0159            114   
0159            115   ; A library of math related functions and utility macros
                579   $LIST
                117   $LIST
03E7            119   
03E7            120   ; Initialization of timers
03E7            121   ;---------------------------------;
03E7            122   ; Routine to initialize the ISR   ;
03E7            123   ; for timer 0                     ;
03E7            124   ;---------------------------------;
03E7            125   Timer0_Init:
03E7 438E08     126            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03EA E589       127            mov a, TMOD
03EC 54F0       128            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03EE 4401       129            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03F0 F589       130            mov TMOD, a
03F2 758CE0     131            mov TH0, #high(TIMER0_RELOAD) 
03F5 758A57     132            mov TL0, #low(TIMER0_RELOAD) 
03F8            133            ; Enable the timer and interrupts
03F8 D2A9       134       setb ET0  ; Enable timer 0 interrupt
03FA D28C       135       setb TR0  ; Start timer 0
03FC 22         136            ret
03FD            137   
03FD            138   ;---------------------------------;
03FD            139   ; ISR for timer 0.  Set to execute;
03FD            140   ; every 1/2048Hz to generate a    ;
03FD            141   ; 2048 Hz wave at pin SOUND_OUT   ;
03FD            142   ;---------------------------------;
03FD            143   Timer0_ISR:
03FD            144            ;clr TF0  ; According to the data sheet this is done for us already.
03FD            145            ; Timer 0 doesn't have 16-bit auto-reload, so
03FD C28C       146            clr TR0
03FF 758CE0     147            mov TH0, #high(TIMER0_RELOAD)
0402 758A57     148            mov TL0, #low(TIMER0_RELOAD)
0405 D28C       149            setb TR0
0407 B284       150            cpl SOUND_OUT ; Toggles the speaker pin at 1000 Hz to play noise
0409 32         151            reti
040A            152   
040A            153   ;---------------------------------;
040A            154   ; Routine to initialize the ISR   ;
040A            155   ; for timer 2                     ;
040A            156   ;---------------------------------;
040A            157   Timer2_Init:
040A            158            ; Initialize timer 2 for periodic interrupts
040A 75C800     159            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
040D 75CDD7     160            mov TH2, #high(TIMER2_RELOAD)
0410 75CC79     161            mov TL2, #low(TIMER2_RELOAD)
0413            162            ; Set the reload value
0413 75C9A0     163            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0416 75CBD7     164            mov RCMP2H, #high(TIMER2_RELOAD)
0419 75CA79     165            mov RCMP2L, #low(TIMER2_RELOAD)
041C            166            ; Init the free running 10 ms counter to zero
041C 753E00     167            mov pwm_counter, #0
041F            168            ; Enable the timer and interrupts
041F 439B80     169            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0422 D2CA       170       setb TR2  ; Enable timer 2
0424 D2AF       171            setb EA ; Enable global interrupts
0426            172   
0426 22         173            ret 
0427            174   
0427            175   ;---------------------------------;
0427            176   ; ISR for timer 2                 ;
0427            177   ;---------------------------------;
0427            178   Timer2_ISR:
0427 C2CF       179            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0429 C0D0       180            push psw
042B C0E0       181            push acc
042D            182            
042D 053E       183            inc pwm_counter
042F C3         184            clr c
0430 E53F       185            mov a, pwm
0432 953E       186            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0434 B3         187            cpl c
0435 9290       188            mov PWM_OUT, c
0437            189            
0437 E53E       190            mov a, pwm_counter
0439 B4640E     191            cjne a, #100, Timer2_ISR_done ; check if 1000 ms have passed
043C 753E00     192            mov pwm_counter, #0
043F D209       193            setb one_second_flag ; set this flag every 1 second, display the time, then it gets cleared
0441 C28C       194            clr TR0 ; default speaker sound to OFF
0443            195   
0443 300604     196            jnb new_state, Timer2_ISR_done ; if we are not entering a new state, jump to the send serial port code
0446 D28C       197            setb TR0 ; Enable timer/counter 0. This line enables the beep sound from the speaker when we enter a new state
0448 C206       198            clr new_state
044A            199   
044A            200   Timer2_ISR_done:
044A D0E0       201            pop acc
044C D0D0       202            pop psw
044E 32         203            reti
044F            204   
044F            205   ; Function declearations begins here:
044F            206   ; We can display a number any way we want.  In this case with four decimal places.
044F            207   Display_formated_BCD:
044F C0E0       208            push acc
0451 7405       208            mov a, #5
0453 14         208            dec a
0454 12013C     208            lcall ?Set_Cursor_2 ; Select column and row
0457 D0E0       208            pop acc
0459 C000       209            push ar0
045B A84E       209            mov r0, bcd+4
045D 120143     209            lcall ?Display_BCD
0460 D000       209            pop ar0
0462 C000       210            push ar0
0464 A84D       210            mov r0, bcd+3
0466 120143     210            lcall ?Display_BCD
0469 D000       210            pop ar0
046B C000       211            push ar0
046D A84C       211            mov r0, bcd+2
046F 120143     211            lcall ?Display_BCD
0472 D000       211            pop ar0
0474 C0E0       212            push acc
0476 742E       212            mov a, #'.'
0478 1200F4     212            lcall ?WriteData
047B D0E0       212            pop acc
047D C000       213            push ar0
047F A84B       213            mov r0, bcd+1
0481 120143     213            lcall ?Display_BCD
0484 D000       213            pop ar0
0486 C000       214            push ar0
0488 A84A       214            mov r0, bcd+0
048A 120143     214            lcall ?Display_BCD
048D D000       214            pop ar0
048F C0E0       215            push acc
0491 7406       215            mov a, #6
0493 14         215            dec a
0494 12013C     215            lcall ?Set_Cursor_2 ; Select column and row
0497 D0E0       215            pop acc
0499            216            
0499 22         217            ret
049A            218   
049A            219   Read_ADC:
049A C2EF       220            clr ADCF
049C D2EE       221            setb ADCS ;  ADC start trigger signal
049E 30EFFD     222       jnb ADCF, $ ; Wait for conversion complete
04A1            223       
04A1            224       ; Read the ADC result and store in [R1, R0]
04A1 E5C2       225       mov a, ADCRL
04A3 540F       226       anl a, #0x0f
04A5 F8         227       mov R0, a
04A6 E5C3       228       mov a, ADCRH   
04A8 C4         229       swap a
04A9 C0E0       230       push acc
04AB 540F       231       anl a, #0x0f
04AD F9         232       mov R1, a
04AE D0E0       233       pop acc
04B0 54F0       234       anl a, #0xf0
04B2 48         235       orl a, R0
04B3 F8         236       mov R0, A
04B4 22         237            ret
04B5            238            
04B5            239   
04B5            240   ; this function reads the overall temperature
04B5            241   ; (cold + hot) junction and turns the value in bcd
04B5            242   Read_Temp:
04B5            243            ; Read the signal connected to AIN7
04B5 53E8F0     244            anl ADCCON0, #0xF0 
04B8 43E807     245            orl ADCCON0, #0x07 ; Select channel 7
04BB            246   
04BB            247   ;Average_ADC:
04BB            248   ;        Load_x(0)
04BB            249   ;        mov r5, #0x100
04BB            250   ;Sum_loop0:
04BB            251   
04BB            252   ; Read the 2.08V LED voltage connected to AIN0 on pin 6
04BB            253            ;anl ADCCON0, #0xF0
04BB            254            ;orl ADCCON0, #0x00 ; Select channel 0
04BB            255   
04BB            256            ;lcall Read_ADC
04BB            257            ; Save result for later use
04BB            258            ;mov VLED_ADC+0, R0
04BB            259            ;mov VLED_ADC+1, R1
04BB            260   Average_ADC:
04BB 754200     261            mov x+0, #low (0 % 0x10000) 
04BE 754300     261            mov x+1, #high(0 % 0x10000) 
04C1 754400     261            mov x+2, #low (0 / 0x10000) 
04C4 754500     261            mov x+3, #high(0 / 0x10000) 
04C7 7D32       262            mov r5, #50
04C9            263   
04C9 53E8F0     264            anl ADCCON0, #0xF0
04CC 43E807     265            orl ADCCON0, #0x07 ; Select channel 7
04CF            266   Sum_Loop:
04CF            267            ; Read the signal connected to AIN7
04CF 12049A     268            lcall Read_ADC
04D2            269       
04D2            270       ; Convert to voltage
04D2 8846       271            mov y+0, R0
04D4 8947       272            mov y+1, R1
04D6            273            ; Pad other bits with zero
04D6 754800     274            mov y+2, #0
04D9 754900     275            mov y+3, #0
04DC 12023C     276            lcall add32
04DF DDEE       277            djnz r5, Sum_Loop
04E1            278   
04E1 754632     279            mov y+0, #low (50 % 0x10000) 
04E4 754700     279            mov y+1, #high(50 % 0x10000) 
04E7 754800     279            mov y+2, #low (50 / 0x10000) 
04EA 754900     279            mov y+3, #high(50 / 0x10000) 
04ED 12037E     280            lcall div32
04F0            281            
04F0            282            ;Load_y(20740) ; The MEASURED LED voltage: 2.074V, with 4 decimal places
04F0 7546B8     283            mov y+0, #low (50360 % 0x10000) 
04F3 7547C4     283            mov y+1, #high(50360 % 0x10000) 
04F6 754800     283            mov y+2, #low (50360 / 0x10000) 
04F9 754900     283            mov y+3, #high(50360 / 0x10000)  ; VCC voltage measured
04FC 1202F1     284            lcall mul32
04FF 7546FF     285            mov y+0, #low (4095 % 0x10000) 
0502 75470F     285            mov y+1, #high(4095 % 0x10000) 
0505 754800     285            mov y+2, #low (4095 / 0x10000) 
0508 754900     285            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
050B 12037E     286            lcall div32
050E            287            ; Retrive the ADC LED value
050E            288            ;mov y+0, VLED_ADC+0
050E            289            ;mov y+1, VLED_ADC+1
050E            290            ; Pad other bits with zero
050E            291            ;mov y+2, #0
050E            292            ;mov y+3, #0
050E            293            ;lcall div32
050E            294   
050E            295   
050E            296            ;Load_y(100)
050E            297            ;lcall mul32
050E            298   
050E 754664     299            mov y+0, #low (100 % 0x10000) 
0511 754700     299            mov y+1, #high(100 % 0x10000) 
0514 754800     299            mov y+2, #low (100 / 0x10000) 
0517 754900     299            mov y+3, #high(100 / 0x10000) 
051A 1202F1     300            lcall mul32
051D            301   
051D 75465B     302            mov y+0, #low (91 % 0x10000) 
0520 754700     302            mov y+1, #high(91 % 0x10000) 
0523 754800     302            mov y+2, #low (91 / 0x10000) 
0526 754900     302            mov y+3, #high(91 / 0x10000) 
0529 12037E     303            lcall div32
052C            304   
052C 754629     305            mov y+0, #low (41 % 0x10000) 
052F 754700     305            mov y+1, #high(41 % 0x10000) 
0532 754800     305            mov y+2, #low (41 / 0x10000) 
0535 754900     305            mov y+3, #high(41 / 0x10000) 
0538 12037E     306            lcall div32
053B            307   
053B 754632     308            mov y+0, #low (50 % 0x10000) 
053E 754700     308            mov y+1, #high(50 % 0x10000) 
0541 754800     308            mov y+2, #low (50 / 0x10000) 
0544 754900     308            mov y+3, #high(50 / 0x10000) 
0547 12023C     309            lcall add32
054A            310   
054A            311            ;Load_y(10000) ;This may be too much, try 100
054A            312            ;lcall mul32
054A            313   
054A            314            ; Convert to BCD and display
054A 120177     315            lcall hex2bcd
054D C0E0       316            push acc
054F 7404       316            mov a, #4
0551 14         316            dec a
0552 12013E     316            lcall ?Set_Cursor_1 ; Select column and row
0555 D0E0       316            pop acc
0557 C000       317            push ar0
0559 A84B       317            mov r0, bcd+1
055B 120143     317            lcall ?Display_BCD
055E D000       317            pop ar0
0560 C000       318            push ar0
0562 A84A       318            mov r0, bcd+0
0564 120143     318            lcall ?Display_BCD
0567 D000       318            pop ar0
0569            319   
0569 7482       320            mov a, #0x82
056B 1200F9     320            lcall ?WriteCommand
056E C0E0       321            push acc
0570 743D       321            mov a, #'='
0572 1200F4     321            lcall ?WriteData
0575 D0E0       321            pop acc
0577            322            
0577            323            ; Wait 50 ms between conversions
0577 7A64       324            mov R2, #100
0579 1205D3     325            lcall waitms
057C            326   
057C 22         327            ret
057D            328   
057D            329   ;------------------------------------;
057D            330   ; Check for pushbutton press         ;
057D            331   ;------------------------------------;
057D            332   LCD_PB:
057D            333            ; Set variables to 1: 'no push button pressed'
057D D200       334            setb PB0
057F D201       335            setb PB1
0581 D202       336            setb PB2
0583 D203       337            setb PB3
0585 D204       338            setb PB4
0587            339            ; The input pin used to check set to '1'
0587 D295       340            setb P1.5
0589            341            
0589            342            ; Check if any push button is pressed
0589 C280       343            clr P0.0
058B C281       344            clr P0.1
058D C282       345            clr P0.2
058F C283       346            clr P0.3
0591 C293       347            clr P1.3
0593 20953C     348            jb P1.5, LCD_PB_Done
0596            349   
0596            350            ; Debounce
0596 7A32       351            mov R2, #50
0598 1205D3     352            lcall waitms
059B 209534     353            jb P1.5, LCD_PB_Done
059E            354   
059E            355            ; Set the LCD data pins to logic 1
059E D280       356            setb P0.0
05A0 D281       357            setb P0.1
05A2 D282       358            setb P0.2
05A4 D283       359            setb P0.3
05A6 D293       360            setb P1.3
05A8            361            
05A8            362            ; Check the push buttons one by one
05A8 C293       363            clr P1.3
05AA A295       364            mov c, P1.5
05AC 9200       365            mov PB0, c
05AE D293       366            setb P1.3
05B0            367   
05B0 C280       368            clr P0.0
05B2 A295       369            mov c, P1.5
05B4 9201       370            mov PB1, c
05B6 D280       371            setb P0.0
05B8            372            
05B8 C281       373            clr P0.1
05BA A295       374            mov c, P1.5
05BC 9202       375            mov PB2, c
05BE D281       376            setb P0.1
05C0            377            
05C0 C282       378            clr P0.2
05C2 A295       379            mov c, P1.5
05C4 9203       380            mov PB3, c
05C6 D282       381            setb P0.2
05C8            382            
05C8 C283       383            clr P0.3
05CA A295       384            mov c, P1.5
05CC 9204       385            mov PB4, c
05CE D283       386            setb P0.3
05D0            387   
05D0            388            ; If a button was pressed, set the flag
05D0 7B01       389            mov R3, #1
05D2            390   
05D2            391   LCD_PB_Done:             
05D2 22         392            ret
05D3            393   
05D3            394   ;---------------------------------;
05D3            395   ; Wait 'R2' milliseconds          ;
05D3            396   ;---------------------------------;
05D3            397   waitms:
05D3 C000       398       push AR0
05D5 C001       399       push AR1
05D7 7928       400   L6: mov R1, #40
05D9 7868       401   L5: mov R0, #104
05DB D8FE       402   L4: djnz R0, L4 ; 4 cycles->4*60.24ns*104=25.0us
05DD D9FA       403       djnz R1, L5 ; 25us*40=1.0ms
05DF DAF6       404       djnz R2, L6 ; number of millisecons to wait passed in R2
05E1 D001       405       pop AR1
05E3 D000       406       pop AR0
05E5 22         407       ret
05E6            408   
05E6            409   
05E6            410   ; Main program code begins here!
05E6            411   initialize:
05E6            412   
05E6            413            ;;;;;;;;;;;;;;;;;;;
05E6            414            ;; CONFIGURATION ;;
05E6            415            ;;;;;;;;;;;;;;;;;;;
05E6            416   
05E6            417            ; Set the stack pointer!
05E6 75817F     418            mov sp, #0x7f
05E9            419   
05E9            420            ; Configure all the pins for biderectional I/O
05E9 75AC00     421            mov     P3M1, #0x00
05EC 75AD00     422            mov     P3M2, #0x00
05EF 75B300     423            mov     P1M1, #0x00
05F2 75B400     424            mov     P1M2, #0x00
05F5 75B100     425            mov     P0M1, #0x00
05F8 75B200     426            mov     P0M2, #0x00
05FB            427   
05FB            428            ; The following code initializes the serial port
05FB 438E10     429            orl     CKCON, #0x10 ; CLK is the input for timer 1
05FE 438780     430            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0601 759852     431            mov     SCON, #0x52
0604 53C4DF     432            anl     T3CON, #0b11011111
0607 53890F     433            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
060A 438920     434            orl     TMOD, #0x20 ; Timer 1 Mode 2
060D 758DF7     435            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0610 D28E       436            setb TR1
0612            437   
0612            438            ; Initialize the pin used by the ADC (P1.1) as input.
0612 43B382     439            orl     P1M1, #0b10000010
0615 53B47D     440            anl     P1M2, #0b01111101
0618            441            
0618            442            ; Initialize and start the ADC:
0618 53E8F0     443            anl ADCCON0, #0xF0
061B 43E807     444            orl ADCCON0, #0x07 ; Select channel 7
061E            445            ; AINDIDS select if some pins are analog inputs or digital I/O:
061E 75F600     446            mov AINDIDS, #0x00 ; Disable all analog inputs
0621 43F681     447            orl AINDIDS, #0b10000001 ; P1.1 is analog input
0624 43E101     448            orl ADCCON1, #0x01 ; Enable ADC
0627            449            
0627            450            ; Initialize the Timers
0627 1203E7     451       lcall Timer0_Init ; Timer 1 (used to play noise from the speaker)
062A 12040A     452       lcall Timer2_Init ; Timer 2 (used to trigger an ISR every 1 second)
062D            453   
062D            454            ; Initialize the LCD - Toggle the 'E' pin
062D 1200FE     455       lcall LCD_4BIT ; Initialize the LCD display in 4 bit mode
0630            456            ;cpl TR0 ; toggle timer 0 immediately, or else it will make noise right away!
0630            457   
0630            458            ; Display the initial strings
0630 C0E0       459            push acc
0632 7401       459            mov a, #1
0634 14         459            dec a
0635 12013E     459            lcall ?Set_Cursor_1 ; Select column and row
0638 D0E0       459            pop acc
063A C083       460            push dph
063C C082       460            push dpl
063E C0E0       460            push acc
0640 90002E     460            mov dptr, #initial_msg1
0643 120131     460            lcall ?Send_Constant_String
0646 D0E0       460            pop acc
0648 D082       460            pop dpl
064A D083       460            pop dph
064C            461   
064C C0E0       462            push acc
064E 7401       462            mov a, #1
0650 14         462            dec a
0651 12013C     462            lcall ?Set_Cursor_2 ; Select column and row
0654 D0E0       462            pop acc
0656 C083       463            push dph
0658 C082       463            push dpl
065A C0E0       463            push acc
065C 90003F     463            mov dptr, #initial_mgs2
065F 120131     463            lcall ?Send_Constant_String
0662 D0E0       463            pop acc
0664 D082       463            pop dpl
0666 D083       463            pop dph
0668            464            
0668            465            ; Set the following variables to zero on startup
0668 7400       466            mov a, #0x0
066A            467            ;da a
066A F53D       468            mov current_state, a
066C F505       469            mov display_time, a
066E            470            ;mov current_soak_time, a
066E            471   
066E 7430       472            mov a, #0x30
0670            473            ;da a
0670 F532       474            mov soak_temp, a
0672            475            
0672 75423C     476            mov x+0, #low (60 % 0x10000) 
0675 754300     476            mov x+1, #high(60 % 0x10000) 
0678 754400     476            mov x+2, #low (60 / 0x10000) 
067B 754500     476            mov x+3, #high(60 / 0x10000) 
067E 854233     477            mov soak_time+0, x+0
0681 854334     478            mov soak_time+1, x+1
0684 753500     479            mov soak_time+2, #0
0687 753600     480            mov soak_time+3, #0
068A            481   
068A            482            ;mov a, #0x200
068A            483            ;da a
068A 7542C8     484            mov x+0, #low (200 % 0x10000) 
068D 754300     484            mov x+1, #high(200 % 0x10000) 
0690 754400     484            mov x+2, #low (200 / 0x10000) 
0693 754500     484            mov x+3, #high(200 / 0x10000) 
0696 854237     485            mov reflow_temp+0, x+0
0699 854338     486            mov reflow_temp+1, x+1
069C 753900     487            mov reflow_temp+2, #0
069F 753A00     488            mov reflow_temp+3, #0
06A2            489            ;mov reflow_temp, #0x200
06A2            490   
06A2 7445       491            mov a, #0x45
06A4            492            ;da a
06A4 F539       493            mov reflow_time, a
06A6            494   
06A6            495   
06A6            496   ;;;;;;;;;;;;;;;;;;;;;;;;
06A6            497   ; FINITE STATE MACHINE ;
06A6            498   ;;;;;;;;;;;;;;;;;;;;;;;;
06A6            499   
06A6            500   ; Start of the finite state machine
06A6            501   
06A6            502   ; STATE 0 - Off State (power 0%)
06A6            503   off_state:
06A6            504   
06A6 E4         505            clr a    
06A7 D2CA       506            setb TR2 ; Start Timer 2
06A9 C28C       507            clr TR0 
06AB 753F00     508            mov pwm, #0 ; set the oven power to 0 in this state
06AE            509            
06AE E4         510            clr a
06AF C207       511            clr cooling_done 
06B1            512   
06B1            513            ; Display the initial strings
06B1 C0E0       514            push acc
06B3 7401       514            mov a, #1
06B5 14         514            dec a
06B6 12013E     514            lcall ?Set_Cursor_1 ; Select column and row
06B9 D0E0       514            pop acc
06BB C083       515            push dph
06BD C082       515            push dpl
06BF C0E0       515            push acc
06C1 90002E     515            mov dptr, #initial_msg1
06C4 120131     515            lcall ?Send_Constant_String
06C7 D0E0       515            pop acc
06C9 D082       515            pop dpl
06CB D083       515            pop dph
06CD            516   
06CD C0E0       517            push acc
06CF 7401       517            mov a, #1
06D1 14         517            dec a
06D2 12013C     517            lcall ?Set_Cursor_2 ; Select column and row
06D5 D0E0       517            pop acc
06D7 C083       518            push dph
06D9 C082       518            push dpl
06DB C0E0       518            push acc
06DD 90003F     518            mov dptr, #initial_mgs2
06E0 120131     518            lcall ?Send_Constant_String
06E3 D0E0       518            pop acc
06E5 D082       518            pop dpl
06E7 D083       518            pop dph
06E9            519   
06E9            520            ; set the initial values on the screen
06E9 C0E0       521            push acc
06EB 7403       521            mov a, #3
06ED 14         521            dec a
06EE 12013C     521            lcall ?Set_Cursor_2 ; Select column and row
06F1 D0E0       521            pop acc ; display the initial soak temperature
06F3 C000       522            push ar0
06F5 A832       522            mov r0, soak_temp
06F7 120143     522            lcall ?Display_BCD
06FA D000       522            pop ar0
06FC            523   
06FC C0E0       524            push acc
06FE 7405       524            mov a, #5
0700 14         524            dec a
0701 12013C     524            lcall ?Set_Cursor_2 ; Select column and row
0704 D0E0       524            pop acc ; display the initial soak time
0706 853342     525            mov x+0, soak_time+0
0709 853443     526            mov x+1, soak_time+1
070C 754400     527            mov x+2, #0
070F 754500     528            mov x+3, #0
0712 120177     529            lcall hex2bcd
0715 C000       530            push ar0
0717 A84B       530            mov r0, bcd+1
0719 120143     530            lcall ?Display_BCD
071C D000       530            pop ar0
071E C000       531            push ar0
0720 A84A       531            mov r0, bcd+0
0722 120143     531            lcall ?Display_BCD
0725 D000       531            pop ar0
0727 C0E0       532            push acc
0729 7405       532            mov a, #5
072B 14         532            dec a
072C 12013C     532            lcall ?Set_Cursor_2 ; Select column and row
072F D0E0       532            pop acc
0731 C0E0       533            push acc
0733 742C       533            mov a, #','
0735 1200F4     533            lcall ?WriteData
0738 D0E0       533            pop acc
073A            534   
073A C0E0       535            push acc
073C 740A       535            mov a, #10
073E 14         535            dec a
073F 12013C     535            lcall ?Set_Cursor_2 ; Select column and row
0742 D0E0       535            pop acc
0744            535    ; display the initial reflow temperature
0744 853742     536            mov x+0, reflow_temp+0
0747 853843     537            mov x+1, reflow_temp+1
074A 754400     538            mov x+2, #0
074D 754500     539            mov x+3, #0
0750 120177     540            lcall hex2bcd
0753            541   
0753 C000       542            push ar0
0755 A84B       542            mov r0, bcd+1
0757 120143     542            lcall ?Display_BCD
075A D000       542            pop ar0
075C C000       543            push ar0
075E A84A       543            mov r0, bcd+0
0760 120143     543            lcall ?Display_BCD
0763 D000       543            pop ar0
0765            544   
0765 C0E0       545            push acc
0767 740A       545            mov a, #10
0769 14         545            dec a
076A 12013C     545            lcall ?Set_Cursor_2 ; Select column and row
076D D0E0       545            pop acc
076F C0E0       546            push acc
0771 7472       546            mov a, #'r'
0773 1200F4     546            lcall ?WriteData
0776 D0E0       546            pop acc
0778 C0E0       547            push acc
077A 740E       547            mov a, #14
077C 14         547            dec a
077D 12013C     547            lcall ?Set_Cursor_2 ; Select column and row
0780 D0E0       547            pop acc
0782 C0E0       548            push acc
0784 742C       548            mov a, #','
0786 1200F4     548            lcall ?WriteData
0789 D0E0       548            pop acc
078B            549   
078B C0E0       550            push acc
078D 740F       550            mov a, #15
078F 14         550            dec a
0790 12013C     550            lcall ?Set_Cursor_2 ; Select column and row
0793 D0E0       550            pop acc ; display the initial reflow time
0795 C000       551            push ar0
0797 A839       551            mov r0, reflow_time+0
0799 120143     551            lcall ?Display_BCD
079C D000       551            pop ar0
079E            552   
079E            553            ; we first want the user to set the soak temperature
079E            554            soak_temp_button:
079E 12057D     555            lcall LCD_PB ; check for pushbutton presses
07A1 7A32       556            mov r2, #50
07A3 1205D3     557            lcall waitms
07A6 12057D     558            lcall LCD_PB 
07A9            559            
07A9 300008     560            jnb PB0, inc_soak_temp ; if the increment button is pressed
07AC 300112     561            jnb PB1, dec_soak_temp ; if the decrement button is pressed
07AF 300235     562            jnb PB2, soak_time_button ; if the next button is pressed
07B2 801E       563            sjmp display_soak_temp ; check button presses again
07B4            564   
07B4            565            inc_soak_temp:
07B4 E532       566            mov a, soak_temp
07B6 2401       567            add a, #0x01
07B8 D4         568            da a
07B9 B47012     569            cjne a, #0x70, continue1
07BC 753230     570            mov soak_temp, #0x30
07BF 8011       571            sjmp display_soak_temp
07C1            572   
07C1            573            dec_soak_temp:
07C1 E532       574            mov a, soak_temp
07C3 2499       575            add a, #0x99
07C5 D4         576            da a
07C6 B42905     577            cjne a, #0x29, continue1
07C9 753270     578            mov soak_temp, #0x70
07CC 8004       579            sjmp display_soak_temp
07CE            580   
07CE            581            continue1:
07CE F532       582            mov soak_temp, a
07D0 8000       583            sjmp display_soak_temp
07D2            584            
07D2            585            display_soak_temp:
07D2 C0E0       586            push acc
07D4 7403       586            mov a, #3
07D6 14         586            dec a
07D7 12013C     586            lcall ?Set_Cursor_2 ; Select column and row
07DA D0E0       586            pop acc ; display the current soak temperature
07DC C000       587            push ar0
07DE A832       587            mov r0, soak_temp
07E0 120143     587            lcall ?Display_BCD
07E3 D000       587            pop ar0
07E5 80B7       588            sjmp soak_temp_button
07E7            589   
07E7            590            ; next we want to user the set the soak time (in seconds)
07E7            591            soak_time_button:
07E7 12057D     592            lcall LCD_PB ; check for pushbutton presses
07EA 7A32       593            mov r2, #50
07EC 1205D3     594            lcall waitms
07EF 12057D     595            lcall LCD_PB
07F2            596            
07F2 300008     597            jnb PB0, inc_soak_time ; if the increment button is pressed
07F5 300109     598            jnb PB1, dec_soak_time ; if the decrement button is pressed
07F8 30024A     599            jnb PB2, reflow_temp_button ; if the next button is pressed
07FB 8008       600            sjmp display_soak_time ; check button presses again
07FD            601   
07FD            602            inc_soak_time:
07FD 0533       603            inc soak_time
07FF 8004       604            sjmp display_soak_time
0801            605            
0801            606            dec_soak_time:
0801 1533       607            dec soak_time
0803            608            ;mov soak_time, a
0803            609            
0803            610            continue2:
0803            611            ;mov soak_time, a
0803 8000       612            sjmp display_soak_time
0805            613   
0805            614            display_soak_time:
0805 C0E0       615            push acc
0807 7405       615            mov a, #5
0809 14         615            dec a
080A 12013C     615            lcall ?Set_Cursor_2 ; Select column and row
080D D0E0       615            pop acc ; display the initial soak time
080F 853342     616            mov x+0, soak_time+0
0812 853443     617            mov x+1, soak_time+1
0815 754400     618            mov x+2, #0
0818 754500     619            mov x+3, #0
081B 120177     620            lcall hex2bcd
081E C000       621            push ar0
0820 A84B       621            mov r0, bcd+1
0822 120143     621            lcall ?Display_BCD
0825 D000       621            pop ar0
0827 C000       622            push ar0
0829 A84A       622            mov r0, bcd+0
082B 120143     622            lcall ?Display_BCD
082E D000       622            pop ar0
0830 C0E0       623            push acc
0832 7405       623            mov a, #5
0834 14         623            dec a
0835 12013C     623            lcall ?Set_Cursor_2 ; Select column and row
0838 D0E0       623            pop acc
083A C0E0       624            push acc
083C 742C       624            mov a, #','
083E 1200F4     624            lcall ?WriteData
0841 D0E0       624            pop acc
0843 80A2       625            sjmp soak_time_button
0845            626   
0845            627            ; third, we want the user to set the reflow temperature 
0845            628            reflow_temp_button:
0845 12057D     629            lcall LCD_PB ; check for pushbutton presses
0848 7A32       630            mov r2, #50
084A 1205D3     631            lcall waitms
084D 12057D     632            lcall LCD_PB
0850            633            
0850 300008     634            jnb PB0, inc_reflow_temp ; if the increment button is pressed
0853 300109     635            jnb PB1, dec_reflow_temp ; if the decrement button is pressed
0856 300263     636            jnb PB2, reflow_time_button ; if the next button is pressed
0859 80EA       637            sjmp reflow_temp_button ; check button presses again
085B            638   
085B            639            inc_reflow_temp:
085B            640            ;mov a, reflow_temp+0
085B            641            ;add a, #0x01
085B            642            ;da a
085B            643            ;cjne a, #0x50, continue3
085B            644            ;mov reflow_temp+0, #0x00
085B            645            ;mov reflow_temp+0, a
085B            646            
085B 0537       647            inc reflow_temp
085D 800A       648            sjmp display_reflow_temp
085F            649   
085F            650            dec_reflow_temp:
085F 1537       651            dec reflow_temp         
0861 8006       652            sjmp display_reflow_temp
0863            653   
0863            654            continue3:
0863 F537       655            mov reflow_temp+0, a
0865 8002       656            sjmp display_reflow_temp
0867 F537       657            mov reflow_temp+0, a 
0869            658   
0869            659            display_reflow_temp:
0869            660            ;Set_Cursor(2,12) ; display the current reflow temperature
0869            661            ;Display_BCD(reflow_temp+0)
0869            662   
0869 C0E0       663            push acc
086B 740A       663            mov a, #10
086D 14         663            dec a
086E 12013C     663            lcall ?Set_Cursor_2 ; Select column and row
0871 D0E0       663            pop acc ; display the initial reflow temperature
0873 853742     664            mov x+0, reflow_temp+0
0876 853843     665            mov x+1, reflow_temp+1
0879 754400     666            mov x+2, #0
087C 754500     667            mov x+3, #0
087F 120177     668            lcall hex2bcd
0882            669   
0882 C000       670            push ar0
0884 A84B       670            mov r0, bcd+1
0886 120143     670            lcall ?Display_BCD
0889 D000       670            pop ar0
088B C000       671            push ar0
088D A84A       671            mov r0, bcd+0
088F 120143     671            lcall ?Display_BCD
0892 D000       671            pop ar0
0894            672   
0894 C0E0       673            push acc
0896 740A       673            mov a, #10
0898 14         673            dec a
0899 12013C     673            lcall ?Set_Cursor_2 ; Select column and row
089C D0E0       673            pop acc
089E C0E0       674            push acc
08A0 7472       674            mov a, #'r'
08A2 1200F4     674            lcall ?WriteData
08A5 D0E0       674            pop acc
08A7 C0E0       675            push acc
08A9 740E       675            mov a, #14
08AB 14         675            dec a
08AC 12013C     675            lcall ?Set_Cursor_2 ; Select column and row
08AF D0E0       675            pop acc
08B1 C0E0       676            push acc
08B3 742C       676            mov a, #','
08B5 1200F4     676            lcall ?WriteData
08B8 D0E0       676            pop acc
08BA            677   
08BA 8089       678            sjmp reflow_temp_button
08BC            679   
08BC            680            ; finally, we want the user to set the reflow time 
08BC            681            reflow_time_button:
08BC 12057D     682            lcall LCD_PB ; check for pushbutton presses
08BF 7A32       683            mov r2, #50
08C1 1205D3     684            lcall waitms
08C4 12057D     685            lcall LCD_PB
08C7            686            
08C7 300008     687            jnb PB0, inc_reflow_time ; if the increment button is pressed
08CA 300112     688            jnb PB1, dec_reflow_time ; if the decrement button is pressed
08CD 300237     689            jnb PB2, wait_for_start ; if the next button is pressed
08D0 80EA       690            sjmp reflow_time_button ; check button presses again
08D2            691   
08D2            692            inc_reflow_time:
08D2 E539       693            mov a, reflow_time
08D4 2401       694            add a, #0x01
08D6 D4         695            da a
08D7 B48012     696            cjne a, #0x80, continue4
08DA 753940     697            mov reflow_time, #0x40
08DD 8013       698            sjmp display_reflow_time
08DF            699   
08DF            700            dec_reflow_time:
08DF E539       701            mov a, reflow_time
08E1 2499       702            add a, #0x99
08E3 D4         703            da a
08E4 B43905     704            cjne a, #0x39, continue4
08E7 753980     705            mov reflow_time, #0x80
08EA 8006       706            sjmp display_reflow_time
08EC            707   
08EC            708            continue4:
08EC F539       709            mov reflow_time, a
08EE 8002       710            sjmp display_reflow_time
08F0 F539       711            mov reflow_time, a 
08F2            712   
08F2            713            display_reflow_time:
08F2 C0E0       714            push acc
08F4 740F       714            mov a, #15
08F6 14         714            dec a
08F7 12013C     714            lcall ?Set_Cursor_2 ; Select column and row
08FA D0E0       714            pop acc ; display the current reflow time
08FC C000       715            push ar0
08FE A839       715            mov r0, reflow_time
0900 120143     715            lcall ?Display_BCD
0903 D000       715            pop ar0
0905 80B5       716            sjmp reflow_time_button 
0907            717   
0907            718            ; if we reach this label, all paramters have been set
0907            719            ; we are now waiting for the user to press the start/stop button (PB4) to begin
0907            720            wait_for_start:
0907 12057D     721            lcall LCD_PB ; check for pushbuttons presses
090A 7A32       722            mov r2, #50
090C 1205D3     723            lcall waitms
090F 12057D     724            lcall LCD_PB
0912 2004F2     725            jb PB4, wait_for_start ; infinite loop if the start button is not pressed
0915 020918     726            ljmp preheat_state
0918            727            ;mov current_state, #1 ; if the start button is pressed, move to state 1 (preheat)
0918            728   
0918            729   ; STATE 1 - Preheat State (increase temperature to soak_temp - power 100%), check for it to reach over 50 C within 60 seconds
0918            730   preheat_state:
0918            731    
0918 E4         732            clr a 
0919 7401       733            mov a, #0x01
091B 1200F9     733            lcall ?WriteCommand ; clear the LCD
091E 7A02       734            mov R2, #2
0920 1205D3     735            lcall waitms
0923 C0E0       736            push acc
0925 7401       736            mov a, #1
0927 14         736            dec a
0928 12013E     736            lcall ?Set_Cursor_1 ; Select column and row
092B D0E0       736            pop acc
092D C083       737            push dph
092F C082       737            push dpl
0931 C0E0       737            push acc
0933 90002E     737            mov dptr, #initial_msg1
0936 120131     737            lcall ?Send_Constant_String
0939 D0E0       737            pop acc
093B D082       737            pop dpl
093D D083       737            pop dph
093F 753F64     738            mov pwm, #100 ; set the oven power to 100% in this state
0942            739   
0942 D206       740            setb new_state
0944 E532       741            mov a, soak_temp
0946 2451       742            add a, #81
0948 F532       743            mov soak_temp, a
094A            744   
094A            745            ; display the working message string
094A C0E0       746            push acc
094C 7401       746            mov a, #1
094E 14         746            dec a
094F 12013C     746            lcall ?Set_Cursor_2 ; Select column and row
0952 D0E0       746            pop acc
0954 C083       747            push dph
0956 C082       747            push dpl
0958 C0E0       747            push acc
095A 900050     747            mov dptr, #preheat_mgs
095D 120131     747            lcall ?Send_Constant_String
0960 D0E0       747            pop acc
0962 D082       747            pop dpl
0964 D083       747            pop dph
0966            748   
0966            749            ; reset the state_time
0966 E4         750            clr a
0967 753C00     751            mov state_time, #0x00
096A            752   
096A            753            ; check if the current temperature is equal to the user set soak temperature
096A            754            check_soak_temp:
096A            755            ; every 1 second, update the display
096A 30092F     756            jnb one_second_flag, read_soak_temp
096D C28C       757            clr TR0
096F 1204B5     758            lcall Read_Temp
0972 E53C       759            mov a, state_time
0974 2401       760            add a, #0x01
0976 D4         761            da a 
0977 F53C       762            mov state_time, a 
0979 C0E0       763            push acc
097B 7403       763            mov a, #3
097D 14         763            dec a
097E 12013C     763            lcall ?Set_Cursor_2 ; Select column and row
0981 D0E0       763            pop acc
0983            763   
0983 C000       764            push ar0
0985 A83C       764            mov r0, state_time
0987 120143     764            lcall ?Display_BCD
098A D000       764            pop ar0
098C            765   
098C            766            ; send the letter A to the serial
098C            767       ;mov a, #0x41 ; ASCII for 'A'
098C            768       ;lcall putchar
098C            769            ;Send_BCD(bcd+2)
098C            770            ; write decimal point
098C            771       ;mov a, #0x2E ; ASCII for '.'
098C            772       ;lcall putchar
098C            773            ;Send_BCD(bcd+1)
098C C000       774            push ar0
098E A84A       774            mov r0, bcd+0
0990 120161     774            lcall ?Send_BCD
0993 D000       774            pop ar0
0995            775            ; write newline character
0995 740A       776       mov a, #0x0A
0997 120159     777       lcall putchar
099A C209       778            clr one_second_flag
099C            779   
099C            780            read_soak_temp:
099C            781            ; move the soak_temp variable to y
099C 853246     782            mov y+0, soak_temp
099F 754700     783            mov y+1, #0
09A2 754800     784            mov y+2, #0
09A5 754900     785            mov y+3, #0
09A8            786   
09A8            787            ; compare x and y (current temperature vs soak temperature)
09A8 12029B     788            lcall x_gt_y ; sets the mf bit if x > y
09AB 200825     789            jb mf, soak_state ; if we have reached the soak_temp, check for an error 
09AE            790   
09AE            791            ; check if the current temperature is less than 50 degrees
09AE            792            check_for_error:
09AE 754632     793            mov y+0, #low (50 % 0x10000) 
09B1 754700     793            mov y+1, #high(50 % 0x10000) 
09B4 754800     793            mov y+2, #low (50 / 0x10000) 
09B7 754900     793            mov y+3, #high(50 / 0x10000) 
09BA 12029B     794            lcall x_gt_y ; check if the current temperature is greater than 50 degrees
09BD 20080A     795            jb mf, soak_not_reached ; if we are over 50 degrees, check the temperature again
09C0            796   
09C0            797            ; if the current temperature is less than 50 degrees, check the state time
09C0            798            error: 
09C0 7E00       799            mov R6, #0
09C2 AE3C       800            mov R6, state_time
09C4 BE6003     801            cjne R6, #0x60, soak_not_reached ; if less than 60 seconds have passed, we have not reached the termination condition
09C7 0206A6     802            ljmp off_state ; if at least 60 seconds have passed, we must terminate the program 
09CA            803   
09CA            804            ; if we are not ready to procede to soak, check the stop button
09CA            805            soak_not_reached:
09CA 12057D     806            lcall LCD_PB ; check for pushbutton presses
09CD 20049A     807            jb PB4, check_soak_temp 
09D0 0206A6     808            ljmp off_state
09D3            809   
09D3            810   
09D3            811   ; STATE 2 - Soak State (maintain temperature - power 20%)
09D3            812   soak_state: 
09D3            813            
09D3 E4         814            clr a
09D4 7401       815            mov a, #0x01
09D6 1200F9     815            lcall ?WriteCommand ; clear the LCD
09D9 7A02       816            mov R2, #2
09DB 1205D3     817            lcall waitms
09DE C0E0       818            push acc
09E0 7401       818            mov a, #1
09E2 14         818            dec a
09E3 12013E     818            lcall ?Set_Cursor_1 ; Select column and row
09E6 D0E0       818            pop acc
09E8 C083       819            push dph
09EA C082       819            push dpl
09EC C0E0       819            push acc
09EE 90002E     819            mov dptr, #initial_msg1
09F1 120131     819            lcall ?Send_Constant_String
09F4 D0E0       819            pop acc
09F6 D082       819            pop dpl
09F8 D083       819            pop dph
09FA 753F14     820            mov pwm, #20 ; set the oven power to 100% in this state
09FD            821   
09FD D206       822            setb new_state
09FF            823            ; display the working message string
09FF C0E0       824            push acc
0A01 7401       824            mov a, #1
0A03 14         824            dec a
0A04 12013C     824            lcall ?Set_Cursor_2 ; Select column and row
0A07 D0E0       824            pop acc
0A09 C083       825            push dph
0A0B C082       825            push dpl
0A0D C0E0       825            push acc
0A0F 900061     825            mov dptr, #soak_mgs
0A12 120131     825            lcall ?Send_Constant_String
0A15 D0E0       825            pop acc
0A17 D082       825            pop dpl
0A19 D083       825            pop dph
0A1B            826   
0A1B            827            ; reset the state_time
0A1B E4         828            clr a
0A1C F53C       829            mov state_time, a
0A1E            830   
0A1E            831            check_soak_time:
0A1E            832            ; every 1 second, update the display
0A1E 30092F     833            jnb one_second_flag, read_soak_time
0A21 C28C       834            clr TR0
0A23 1204B5     835            lcall Read_Temp ; read the current temperature - store result in x
0A26 E53C       836            mov a, state_time
0A28 2401       837            add a, #0x01
0A2A D4         838            da a 
0A2B F53C       839            mov state_time, a
0A2D C0E0       840            push acc
0A2F 7403       840            mov a, #3
0A31 14         840            dec a
0A32 12013C     840            lcall ?Set_Cursor_2 ; Select column and row
0A35 D0E0       840            pop acc
0A37 C000       841            push ar0
0A39 A83C       841            mov r0, state_time
0A3B 120143     841            lcall ?Display_BCD
0A3E D000       841            pop ar0
0A40            842   
0A40            843            ; send the letter B to the serial
0A40            844       ;mov a, #0x42 ; ASCII for 'B'
0A40            845       ;lcall putchar
0A40            846            ;Send_BCD(bcd+2)
0A40            847            ; write decimal point
0A40            848       ;mov a, #0x2E ; ASCII for '.'
0A40            849       ;lcall putchar
0A40            850            ;Send_BCD(bcd+1)
0A40 C000       851            push ar0
0A42 A84A       851            mov r0, bcd+0
0A44 120161     851            lcall ?Send_BCD
0A47 D000       851            pop ar0
0A49            852            ; write newline character
0A49 740A       853       mov a, #0x0A
0A4B 120159     854       lcall putchar
0A4E C209       855            clr one_second_flag
0A50            856   
0A50            857            read_soak_time:
0A50 853342     858            mov x+0, soak_time
0A53 754300     859            mov x+1, #0
0A56 754400     860            mov x+2, #0
0A59 754500     861            mov x+3, #0
0A5C            862   
0A5C 120177     863            lcall hex2bcd
0A5F E54A       864            mov a, bcd+0
0A61            865            
0A61 B53C02     866            cjne a, state_time, soak_time_not_reached
0A64 8009       867            sjmp ramp_state
0A66            868   
0A66            869            soak_time_not_reached:
0A66 12057D     870            lcall LCD_PB ; check for pushbutton presses
0A69 2004B2     871            jb PB4, check_soak_time 
0A6C 0206A6     872            ljmp off_state
0A6F            873   
0A6F            874   ; STATE 3 - Ramp to Reflow State (increase temperature to reflow_temp - power 100%)
0A6F            875   ramp_state:
0A6F            876   
0A6F E4         877            clr a 
0A70 7401       878            mov a, #0x01
0A72 1200F9     878            lcall ?WriteCommand ; clear the LCD
0A75 7A02       879            mov R2, #2
0A77 1205D3     880            lcall waitms
0A7A            881   
0A7A C0E0       882            push acc
0A7C 7401       882            mov a, #1
0A7E 14         882            dec a
0A7F 12013E     882            lcall ?Set_Cursor_1 ; Select column and row
0A82 D0E0       882            pop acc
0A84 C083       883            push dph
0A86 C082       883            push dpl
0A88 C0E0       883            push acc
0A8A 90002E     883            mov dptr, #initial_msg1
0A8D 120131     883            lcall ?Send_Constant_String
0A90 D0E0       883            pop acc
0A92 D082       883            pop dpl
0A94 D083       883            pop dph
0A96 753F64     884            mov pwm, #100 ; set the oven power to 100% in this state
0A99            885            
0A99            886            ; reset the state_time
0A99 E4         887            clr a
0A9A F53C       888            mov state_time, a
0A9C            889   
0A9C D206       890            setb new_state
0A9E            891            ; display the working message string
0A9E C0E0       892            push acc
0AA0 7401       892            mov a, #1
0AA2 14         892            dec a
0AA3 12013C     892            lcall ?Set_Cursor_2 ; Select column and row
0AA6 D0E0       892            pop acc
0AA8 C083       893            push dph
0AAA C082       893            push dpl
0AAC C0E0       893            push acc
0AAE 900072     893            mov dptr, #ramp_mgs
0AB1 120131     893            lcall ?Send_Constant_String
0AB4 D0E0       893            pop acc
0AB6 D082       893            pop dpl
0AB8 D083       893            pop dph
0ABA            894   
0ABA            895            ; reading the ramp temperature to determine if we should enter
0ABA            896            ; reflow
0ABA            897            check_ramp_temp:
0ABA            898            ; every 1 second, update the display
0ABA 300934     899            jnb one_second_flag, read_ramp_temp
0ABD C28C       900            clr TR0
0ABF 1204B5     901            lcall Read_Temp ; read the current temperature - store result in x
0AC2 E53C       902            mov a, state_time
0AC4 2401       903            add a, #0x01
0AC6 D4         904            da a 
0AC7 F53C       905            mov state_time, a
0AC9 C0E0       906            push acc
0ACB 7403       906            mov a, #3
0ACD 14         906            dec a
0ACE 12013C     906            lcall ?Set_Cursor_2 ; Select column and row
0AD1 D0E0       906            pop acc
0AD3 C000       907            push ar0
0AD5 A83C       907            mov r0, state_time
0AD7 120143     907            lcall ?Display_BCD
0ADA D000       907            pop ar0
0ADC            908   
0ADC            909            ; send the letter C to the serial
0ADC 7443       910       mov a, #0x43 ; ASCII for 'C'
0ADE 120159     911       lcall putchar
0AE1            912            ;Send_BCD(bcd+2)
0AE1            913            ; write decimal point
0AE1            914       ;mov a, #0x2E ; ASCII for '.'
0AE1            915       ;lcall putchar
0AE1            916            ;Send_BCD(bcd+1)
0AE1 C000       917            push ar0
0AE3 A84A       917            mov r0, bcd+0
0AE5 120161     917            lcall ?Send_BCD
0AE8 D000       917            pop ar0
0AEA            918            ; write newline character
0AEA 740A       919       mov a, #0x0A
0AEC 120159     920       lcall putchar
0AEF C209       921            clr one_second_flag
0AF1            922   
0AF1            923            read_ramp_temp:
0AF1            924            ; moving the reflow temp value into y
0AF1 853746     925            mov y+0, reflow_temp+0
0AF4 853847     926            mov y+1, reflow_temp+1
0AF7 754800     927            mov y+2, #0
0AFA 754900     928            mov y+3, #0
0AFD            929   
0AFD            930            ; check if the current temperature is equal to the user set soak temperature
0AFD 12029B     931            lcall x_gt_y
0B00 20080C     932            jb mf, reflow_state
0B03            933   
0B03            934            ; if we are not ready to procede to reflow, check the stop button
0B03            935            reflow_not_reached:
0B03 12057D     936            lcall LCD_PB ; check for pushbutton presses
0B06 2004B1     937            jb PB4, check_ramp_temp 
0B09 753D00     938            mov current_state, #0 ; if the stop button is pressed, return to state 0
0B0C 0206A6     939            ljmp off_state
0B0F            940   
0B0F            941   
0B0F            942   ; STATE 4 - Reflow State (maintain temperature - power 20%)
0B0F            943   reflow_state:
0B0F            944   
0B0F E4         945            clr a 
0B10 7401       946            mov a, #0x01
0B12 1200F9     946            lcall ?WriteCommand ; clear the LCD
0B15 7A02       947            mov R2, #2
0B17 1205D3     948            lcall waitms
0B1A            949   
0B1A C0E0       950            push acc
0B1C 7401       950            mov a, #1
0B1E 14         950            dec a
0B1F 12013E     950            lcall ?Set_Cursor_1 ; Select column and row
0B22 D0E0       950            pop acc
0B24 C083       951            push dph
0B26 C082       951            push dpl
0B28 C0E0       951            push acc
0B2A 90002E     951            mov dptr, #initial_msg1
0B2D 120131     951            lcall ?Send_Constant_String
0B30 D0E0       951            pop acc
0B32 D082       951            pop dpl
0B34 D083       951            pop dph
0B36 753F14     952            mov pwm, #20 ; set the oven power to 20% in this state
0B39            953            
0B39 D206       954            setb new_state
0B3B            955            ; display the working message string
0B3B C0E0       956            push acc
0B3D 7401       956            mov a, #1
0B3F 14         956            dec a
0B40 12013C     956            lcall ?Set_Cursor_2 ; Select column and row
0B43 D0E0       956            pop acc
0B45 C083       957            push dph
0B47 C082       957            push dpl
0B49 C0E0       957            push acc
0B4B 900083     957            mov dptr, #reflow_mgs
0B4E 120131     957            lcall ?Send_Constant_String
0B51 D0E0       957            pop acc
0B53 D082       957            pop dpl
0B55 D083       957            pop dph
0B57            958   
0B57            959            ; reset the state_time
0B57 E4         960            clr a
0B58 F53C       961            mov state_time, a
0B5A            962   
0B5A            963            check_reflow_time:
0B5A            964            ; every 1 second, update the display
0B5A 300934     965            jnb one_second_flag, read_reflow_time
0B5D C28C       966            clr TR0
0B5F 1204B5     967            lcall Read_Temp ; read the current temperature - store result in x
0B62 E53C       968            mov a, state_time
0B64 2401       969            add a, #0x01
0B66 D4         970            da a 
0B67 F53C       971            mov state_time, a
0B69 C0E0       972            push acc
0B6B 7403       972            mov a, #3
0B6D 14         972            dec a
0B6E 12013C     972            lcall ?Set_Cursor_2 ; Select column and row
0B71 D0E0       972            pop acc
0B73 C000       973            push ar0
0B75 A83C       973            mov r0, state_time
0B77 120143     973            lcall ?Display_BCD
0B7A D000       973            pop ar0
0B7C            974   
0B7C            975            ; send the letter D to the serial
0B7C 7444       976       mov a, #0x44 ; ASCII for 'D'
0B7E 120159     977       lcall putchar
0B81            978            ;Send_BCD(bcd+2)
0B81            979            ; write decimal point
0B81            980       ;mov a, #0x2E ; ASCII for '.'
0B81            981       ;lcall putchar
0B81            982            ;Send_BCD(bcd+1)
0B81 C000       983            push ar0
0B83 A84A       983            mov r0, bcd+0
0B85 120161     983            lcall ?Send_BCD
0B88 D000       983            pop ar0
0B8A            984            ; write newline character
0B8A 740A       985       mov a, #0x0A
0B8C 120159     986       lcall putchar
0B8F C209       987            clr one_second_flag
0B91            988            
0B91            989            read_reflow_time:
0B91 E539       990            mov a, reflow_time
0B93 B53C02     991            cjne a, state_time, reflow_time_not_reached
0B96 8009       992            sjmp cooling_state
0B98            993   
0B98            994            reflow_time_not_reached:
0B98 12057D     995            lcall LCD_PB ; check for pushbutton presses
0B9B 2004BC     996            jb PB4, check_reflow_time 
0B9E 0206A6     997            ljmp off_state
0BA1            998   
0BA1            999   ; STATE 5 - Cooling State (no power, resets when it is below 60C)
0BA1           1000   cooling_state:
0BA1           1001   
0BA1 E4        1002            clr a 
0BA2 7401      1003            mov a, #0x01
0BA4 1200F9    1003            lcall ?WriteCommand ; clear the LCD
0BA7 7A02      1004            mov R2, #2
0BA9 1205D3    1005            lcall waitms
0BAC           1006   
0BAC C0E0      1007            push acc
0BAE 7401      1007            mov a, #1
0BB0 14        1007            dec a
0BB1 12013E    1007            lcall ?Set_Cursor_1 ; Select column and row
0BB4 D0E0      1007            pop acc
0BB6 C083      1008            push dph
0BB8 C082      1008            push dpl
0BBA C0E0      1008            push acc
0BBC 90002E    1008            mov dptr, #initial_msg1
0BBF 120131    1008            lcall ?Send_Constant_String
0BC2 D0E0      1008            pop acc
0BC4 D082      1008            pop dpl
0BC6 D083      1008            pop dph
0BC8 753F00    1009            mov pwm, #0 ; set the oven power to 100% in this state
0BCB           1010            
0BCB           1011            ; reset the state_time
0BCB E4        1012            clr a
0BCC F53C      1013            mov state_time, a
0BCE           1014   
0BCE D206      1015            setb new_state
0BD0           1016            ; display the working message string
0BD0 C0E0      1017            push acc
0BD2 7401      1017            mov a, #1
0BD4 14        1017            dec a
0BD5 12013C    1017            lcall ?Set_Cursor_2 ; Select column and row
0BD8 D0E0      1017            pop acc
0BDA C083      1018            push dph
0BDC C082      1018            push dpl
0BDE C0E0      1018            push acc
0BE0 900094    1018            mov dptr, #cooling_mgs
0BE3 120131    1018            lcall ?Send_Constant_String
0BE6 D0E0      1018            pop acc
0BE8 D082      1018            pop dpl
0BEA D083      1018            pop dph
0BEC           1019   
0BEC           1020            ; reading the ramp temperature to determine if we should enter
0BEC           1021            ; reflow
0BEC           1022            check_cooling_temp:
0BEC           1023            ; every 1 second, update the display
0BEC 300934    1024            jnb one_second_flag, read_cooling_temp
0BEF C28C      1025            clr TR0
0BF1 1204B5    1026            lcall Read_Temp ; read the current temperature - store result in x
0BF4 E53C      1027            mov a, state_time
0BF6 2401      1028            add a, #0x01
0BF8 D4        1029            da a 
0BF9 F53C      1030            mov state_time, a
0BFB C0E0      1031            push acc
0BFD 7403      1031            mov a, #3
0BFF 14        1031            dec a
0C00 12013C    1031            lcall ?Set_Cursor_2 ; Select column and row
0C03 D0E0      1031            pop acc
0C05           1031   
0C05 C000      1032            push ar0
0C07 A83C      1032            mov r0, state_time
0C09 120143    1032            lcall ?Display_BCD
0C0C D000      1032            pop ar0
0C0E           1033   
0C0E           1034            ;sending to serial
0C0E 7445      1035            mov a, #0x45 ; ASCII for 'E'
0C10 120159    1036       lcall putchar
0C13           1037            ;Send_BCD(bcd+2)
0C13           1038            ; write decimal point
0C13           1039       ;mov a, #0x2E ; ASCII for '.'
0C13           1040       ;lcall putchar
0C13           1041            ;Send_BCD(bcd+1)
0C13 C000      1042            push ar0
0C15 A84A      1042            mov r0, bcd+0
0C17 120161    1042            lcall ?Send_BCD
0C1A D000      1042            pop ar0
0C1C           1043            ; write newline character
0C1C 740A      1044       mov a, #0x0A
0C1E 120159    1045       lcall putchar
0C21 C209      1046            clr one_second_flag
0C23           1047   
0C23           1048            read_cooling_temp:
0C23 75463C    1049            mov y+0, #low (60 % 0x10000) 
0C26 754700    1049            mov y+1, #high(60 % 0x10000) 
0C29 754800    1049            mov y+2, #low (60 / 0x10000) 
0C2C 754900    1049            mov y+3, #high(60 / 0x10000) 
0C2F           1050            ; check if the current temperature is equal to the user set soak temperature
0C2F 12027F    1051            lcall x_lt_y ; mf = 1 if x < y  
0C32 200809    1052            jb mf, jumper
0C35           1053   
0C35           1054            ; if we are not ready to procede to reflow, check the stop button
0C35           1055            cooling_not_reached:
0C35 12057D    1056            lcall LCD_PB ; check for pushbutton presses
0C38 2004B1    1057            jb PB4, check_cooling_temp 
0C3B 753D00    1058            mov current_state, #0 ; if the stop button is pressed, return to state 0
0C3E           1059   
0C3E           1060            jumper:
0C3E 0206A6    1061            ljmp off_state
0C41           1062   
0C41           1063   EN
